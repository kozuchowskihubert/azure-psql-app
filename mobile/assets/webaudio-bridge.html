<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HAOS.fm Web Audio Bridge</title>
</head>
<body>
  <script>
    // HAOS.fm Web Audio Bridge
    // This runs inside a WebView and provides Web Audio API to React Native

    let audioContext = null;
    let activeVoices = [];

    // TB-303 parameters
    let tb303Params = {
      cutoff: 500,
      resonance: 10,
      envMod: 3000,
      decay: 0.3,
      accent: 1.5,
      waveform: 'sawtooth'
    };

    // Initialize Audio Context
    function init() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Resume audio context (required for iOS/mobile)
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            console.log('Audio context resumed');
            sendMessage({ type: 'init_success', sampleRate: audioContext.sampleRate });
          });
        } else {
          sendMessage({ type: 'init_success', sampleRate: audioContext.sampleRate });
        }
        
        console.log('Web Audio initialized:', audioContext.sampleRate, 'state:', audioContext.state);
      } catch (error) {
        sendMessage({ type: 'init_error', error: error.message });
        console.error('Web Audio init error:', error);
      }
    }
    
    // Resume audio context before playing (important for mobile)
    function ensureAudioContext() {
      if (audioContext && audioContext.state === 'suspended') {
        console.log('Resuming audio context...');
        audioContext.resume().then(() => {
          console.log('Audio context resumed, state:', audioContext.state);
        });
      }
    }

    // Play TB-303 style note
    function playTB303(note, velocity = 1.0, accent = false, duration = 0.2) {
      if (!audioContext) {
        console.error('Audio context not initialized');
        return;
      }
      
      // Ensure audio context is running
      ensureAudioContext();

      try {
        const frequency = noteToFrequency(note);
        const now = audioContext.currentTime;

        // Oscillator
        const osc = audioContext.createOscillator();
        osc.type = tb303Params.waveform;
        osc.frequency.value = frequency;

        // Filter (the 303 sound!)
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = tb303Params.cutoff;
        filter.Q.value = tb303Params.resonance;

        // VCA
        const vca = audioContext.createGain();
        vca.gain.value = 0;

        // Connect
        osc.connect(filter);
        filter.connect(vca);
        vca.connect(audioContext.destination);

        // Envelope
        const accentMult = accent ? tb303Params.accent : 1.0;
        const peakVolume = velocity * accentMult * 0.5;
        const filterPeak = tb303Params.cutoff + (tb303Params.envMod * accentMult);

        // Volume envelope
        vca.gain.setValueAtTime(0, now);
        vca.gain.linearRampToValueAtTime(peakVolume, now + 0.001);
        vca.gain.exponentialRampToValueAtTime(peakVolume * 0.3, now + tb303Params.decay);
        vca.gain.exponentialRampToValueAtTime(0.001, now + duration);

        // Filter sweep
        filter.frequency.setValueAtTime(filterPeak, now);
        filter.frequency.exponentialRampToValueAtTime(tb303Params.cutoff, now + tb303Params.decay);

        // Start/stop
        osc.start(now);
        osc.stop(now + duration + 0.1);

        // Cleanup
        setTimeout(() => {
          try {
            osc.disconnect();
            filter.disconnect();
            vca.disconnect();
          } catch (e) {}
        }, (duration + 0.2) * 1000);

      } catch (error) {
        console.error('Play error:', error);
      }
    }

    // Play ARP 2600 style note (dual oscillator modular synth)
    function playARP2600(note, velocity = 1.0, accent = false, duration = 0.3) {
      if (!audioContext) {
        console.error('Audio context not initialized');
        return;
      }
      
      // Ensure audio context is running
      ensureAudioContext();

      try {
        const frequency = noteToFrequency(note);
        const now = audioContext.currentTime;

        // Dual oscillators for thick ARP sound
        const osc1 = audioContext.createOscillator();
        osc1.type = 'sawtooth';
        osc1.frequency.value = frequency;

        const osc2 = audioContext.createOscillator();
        osc2.type = 'square';
        osc2.frequency.value = frequency * 1.01; // Slight detune for thickness

        // Filter (modular synth characteristic)
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 2000 + (accent ? 1000 : 0);
        filter.Q.value = 5;

        // Filter envelope
        const filterAttack = 0.01;
        const filterDecay = 0.3;
        const filterPeak = filter.frequency.value * 3;
        filter.frequency.setValueAtTime(filter.frequency.value, now);
        filter.frequency.exponentialRampToValueAtTime(filterPeak, now + filterAttack);
        filter.frequency.exponentialRampToValueAtTime(filter.frequency.value, now + filterAttack + filterDecay);

        // VCA
        const vca = audioContext.createGain();
        vca.gain.value = 0;

        // Connect
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(vca);
        vca.connect(audioContext.destination);

        // Amplitude envelope (ADSR)
        const attack = 0.01;
        const decay = 0.3;
        const sustain = 0.7;
        const release = 0.2;
        const velocityGain = velocity * 0.5 * (accent ? 1.3 : 1.0);

        vca.gain.setValueAtTime(0, now);
        vca.gain.linearRampToValueAtTime(velocityGain, now + attack);
        vca.gain.exponentialRampToValueAtTime(velocityGain * sustain, now + attack + decay);
        vca.gain.exponentialRampToValueAtTime(0.001, now + duration + release);

        // Start and stop
        osc1.start(now);
        osc2.start(now);
        osc1.stop(now + duration + release);
        osc2.stop(now + duration + release);

        console.log('üéπ Web Audio ARP 2600 played:', note, 'freq:', frequency.toFixed(2), 'Hz');
      } catch (error) {
        console.error('ARP 2600 play error:', error);
      }
    }

    // Play Juno-106 style note (warm chorus ensemble)
    function playJuno106(note, velocity = 1.0, accent = false, duration = 0.3) {
      if (!audioContext) {
        console.error('Audio context not initialized');
        return;
      }
      
      ensureAudioContext();

      try {
        const frequency = noteToFrequency(note);
        const now = audioContext.currentTime;

        // Juno's famous chorus: 3 detuned sawtooth oscillators
        const osc1 = audioContext.createOscillator();
        osc1.type = 'sawtooth';
        osc1.frequency.value = frequency;

        const osc2 = audioContext.createOscillator();
        osc2.type = 'sawtooth';
        osc2.frequency.value = frequency * 1.005; // Slight detune

        const osc3 = audioContext.createOscillator();
        osc3.type = 'sawtooth';
        osc3.frequency.value = frequency * 0.995; // Opposite detune

        // Juno's characteristic warm filter (use stored params)
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = synthParams.juno106.cutoff + (accent ? 800 : 0);
        filter.Q.value = synthParams.juno106.resonance;

        // Gentle filter envelope
        const filterAttack = 0.05;
        const filterDecay = 0.4;
        const filterPeak = filter.frequency.value * 1.8;
        filter.frequency.setValueAtTime(filter.frequency.value, now);
        filter.frequency.exponentialRampToValueAtTime(filterPeak, now + filterAttack);
        filter.frequency.exponentialRampToValueAtTime(filter.frequency.value, now + filterAttack + filterDecay);

        // VCA
        const vca = audioContext.createGain();
        vca.gain.value = 0;

        // Connect (all oscs to filter for chorus effect)
        osc1.connect(filter);
        osc2.connect(filter);
        osc3.connect(filter);
        filter.connect(vca);
        vca.connect(audioContext.destination);

        // Warm, slow envelope (use stored params)
        const attack = synthParams.juno106.attack;
        const decay = synthParams.juno106.decay;
        const sustain = synthParams.juno106.sustain;
        const release = synthParams.juno106.release;
        const velocityGain = velocity * 0.4 * (accent ? 1.2 : 1.0);

        vca.gain.setValueAtTime(0, now);
        vca.gain.linearRampToValueAtTime(velocityGain, now + attack);
        vca.gain.exponentialRampToValueAtTime(velocityGain * sustain, now + attack + decay);
        vca.gain.exponentialRampToValueAtTime(0.001, now + duration + release);

        // Start and stop
        osc1.start(now);
        osc2.start(now);
        osc3.start(now);
        osc1.stop(now + duration + release);
        osc2.stop(now + duration + release);
        osc3.stop(now + duration + release);

        console.log('üéπ Web Audio Juno-106 played:', note, 'freq:', frequency.toFixed(2), 'Hz (warm chorus)');
      } catch (error) {
        console.error('Juno-106 play error:', error);
      }
    }

    // Play Minimoog style note (fat analog bass/lead)
    function playMinimoog(note, velocity = 1.0, accent = false, duration = 0.3) {
      if (!audioContext) {
        console.error('Audio context not initialized');
        return;
      }
      
      ensureAudioContext();

      try {
        const frequency = noteToFrequency(note);
        const now = audioContext.currentTime;

        // Minimoog's 3-oscillator architecture
        const osc1 = audioContext.createOscillator();
        osc1.type = 'sawtooth';
        osc1.frequency.value = frequency;

        const osc2 = audioContext.createOscillator();
        osc2.type = 'triangle';
        osc2.frequency.value = frequency * 0.997; // Slight detune for thickness

        const osc3 = audioContext.createOscillator();
        osc3.type = 'square';
        osc3.frequency.value = frequency * 2; // One octave up

        // Individual gains for oscillator mix
        const osc1Gain = audioContext.createGain();
        osc1Gain.gain.value = 0.5;
        const osc2Gain = audioContext.createGain();
        osc2Gain.gain.value = 0.4;
        const osc3Gain = audioContext.createGain();
        osc3Gain.gain.value = 0.3;

        // Minimoog's famous ladder filter (use stored params)
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = synthParams.minimoog.cutoff + (accent ? 1200 : 0);
        filter.Q.value = synthParams.minimoog.resonance;

        // Aggressive filter envelope
        const filterAttack = 0.005;
        const filterDecay = 0.2;
        const filterPeak = filter.frequency.value * 4;
        filter.frequency.setValueAtTime(filter.frequency.value, now);
        filter.frequency.exponentialRampToValueAtTime(filterPeak, now + filterAttack);
        filter.frequency.exponentialRampToValueAtTime(filter.frequency.value, now + filterAttack + filterDecay);

        // VCA
        const vca = audioContext.createGain();
        vca.gain.value = 0;

        // Connect
        osc1.connect(osc1Gain);
        osc2.connect(osc2Gain);
        osc3.connect(osc3Gain);
        osc1Gain.connect(filter);
        osc2Gain.connect(filter);
        osc3Gain.connect(filter);
        filter.connect(vca);
        vca.connect(audioContext.destination);

        // Punchy envelope (use stored params)
        const attack = synthParams.minimoog.attack;
        const decay = synthParams.minimoog.decay;
        const sustain = synthParams.minimoog.sustain;
        const release = synthParams.minimoog.release;
        const velocityGain = velocity * 0.6 * (accent ? 1.4 : 1.0);

        console.log('üéπ Minimoog params:', synthParams.minimoog);

        vca.gain.setValueAtTime(0, now);
        vca.gain.linearRampToValueAtTime(velocityGain, now + attack);
        vca.gain.exponentialRampToValueAtTime(velocityGain * sustain, now + attack + decay);
        vca.gain.exponentialRampToValueAtTime(0.001, now + duration + release);

        // Start and stop
        osc1.start(now);
        osc2.start(now);
        osc3.start(now);
        osc1.stop(now + duration + release);
        osc2.stop(now + duration + release);
        osc3.stop(now + duration + release);

        console.log('üéπ Web Audio Minimoog played:', note, 'freq:', frequency.toFixed(2), 'Hz (fat analog)');
      } catch (error) {
        console.error('Minimoog play error:', error);
      }
    }

    // Convert note to frequency
    function noteToFrequency(note) {
      const noteMap = {
        'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5,
        'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11
      };

      const match = note.match(/^([A-G]#?)(\d+)$/);
      if (!match) return 440;

      const noteName = match[1];
      const octave = parseInt(match[2]);
      const noteNum = noteMap[noteName];
      const midiNote = (octave + 1) * 12 + noteNum;

      return 440 * Math.pow(2, (midiNote - 69) / 12);
    }

    // Update TB-303 parameters
    // Global synth parameter storage
    const synthParams = {
      juno106: {
        cutoff: 1200,
        resonance: 2,
        attack: 0.03,
        decay: 0.4,
        sustain: 0.6,
        release: 0.3,
        chorusDepth: 0.005
      },
      minimoog: {
        cutoff: 800,
        resonance: 8,
        attack: 0.005,
        decay: 0.2,
        sustain: 0.7,
        release: 0.1,
        osc1Level: 0.5,
        osc2Level: 0.4,
        osc3Level: 0.3
      },
      arp2600: {
        filterCutoff: 2000,
        filterRes: 5,
        attack: 0.01,
        decay: 0.3,
        sustain: 0.5,
        release: 0.5
      }
    };

    function updateParams(params) {
      // Handle TB-303 params
      Object.assign(tb303Params, params);
      
      // Handle Juno-106 params
      if (params.juno106_cutoff !== undefined) synthParams.juno106.cutoff = params.juno106_cutoff;
      if (params.juno106_resonance !== undefined) synthParams.juno106.resonance = params.juno106_resonance;
      if (params.juno106_attack !== undefined) synthParams.juno106.attack = params.juno106_attack;
      if (params.juno106_decay !== undefined) synthParams.juno106.decay = params.juno106_decay;
      if (params.juno106_sustain !== undefined) synthParams.juno106.sustain = params.juno106_sustain;
      if (params.juno106_release !== undefined) synthParams.juno106.release = params.juno106_release;
      if (params.juno106_chorus_depth !== undefined) synthParams.juno106.chorusDepth = params.juno106_chorus_depth;
      
      // Handle Minimoog params
      if (params.minimoog_cutoff !== undefined) synthParams.minimoog.cutoff = params.minimoog_cutoff;
      if (params.minimoog_resonance !== undefined) synthParams.minimoog.resonance = params.minimoog_resonance;
      if (params.minimoog_attack !== undefined) synthParams.minimoog.attack = params.minimoog_attack;
      if (params.minimoog_decay !== undefined) synthParams.minimoog.decay = params.minimoog_decay;
      if (params.minimoog_sustain !== undefined) synthParams.minimoog.sustain = params.minimoog_sustain;
      if (params.minimoog_release !== undefined) synthParams.minimoog.release = params.minimoog_release;
      
      // Handle ARP 2600 params
      if (params.arp2600_cutoff !== undefined) synthParams.arp2600.filterCutoff = params.arp2600_cutoff;
      if (params.arp2600_resonance !== undefined) synthParams.arp2600.filterRes = params.arp2600_resonance;
      if (params.arp2600_attack !== undefined) synthParams.arp2600.attack = params.arp2600_attack;
      if (params.arp2600_decay !== undefined) synthParams.arp2600.decay = params.arp2600_decay;
      if (params.arp2600_sustain !== undefined) synthParams.arp2600.sustain = params.arp2600_sustain;
      if (params.arp2600_release !== undefined) synthParams.arp2600.release = params.arp2600_release;
      
      console.log('üìä Synth params updated:', params);
    }

    // Send message to React Native
    function sendMessage(data) {
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify(data));
      }
    }

    // TR-808/909 Drum Sounds
    function playKick(velocity = 1.0) {
      ensureAudioContext();
      if (!audioContext) return;
      
      const now = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.frequency.setValueAtTime(150, now);
      osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);
      
      gain.gain.setValueAtTime(velocity, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
      
      osc.connect(gain);
      gain.connect(audioContext.destination);
      
      osc.start(now);
      osc.stop(now + 0.5);
      
      console.log('ü•Å Web Audio Kick played');
    }
    
    function playSnare(velocity = 1.0) {
      ensureAudioContext();
      if (!audioContext) return;
      
      const now = audioContext.currentTime;
      
      // Noise
      const bufferSize = audioContext.sampleRate * 0.2;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      
      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;
      
      const noiseGain = audioContext.createGain();
      noiseGain.gain.setValueAtTime(velocity * 0.5, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      
      noise.connect(noiseGain);
      noiseGain.connect(audioContext.destination);
      
      noise.start(now);
      
      console.log('ü•Å Web Audio Snare played');
    }
    
    function playHihat(velocity = 1.0, open = false) {
      ensureAudioContext();
      if (!audioContext) return;
      
      const now = audioContext.currentTime;
      const duration = open ? 0.3 : 0.05;
      
      // High-pass filtered noise
      const bufferSize = audioContext.sampleRate * duration;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      
      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;
      
      const filter = audioContext.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 7000;
      
      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(velocity * 0.3, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
      
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);
      
      noise.start(now);
      
      console.log('ü•Å Web Audio Hihat played');
    }
    
    function playClap(velocity = 1.0) {
      ensureAudioContext();
      if (!audioContext) return;
      
      const now = audioContext.currentTime;
      
      // Multiple short noise bursts for clap
      for (let i = 0; i < 3; i++) {
        const startTime = now + (i * 0.01);
        
        const bufferSize = audioContext.sampleRate * 0.05;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        for (let j = 0; j < bufferSize; j++) {
          data[j] = Math.random() * 2 - 1;
        }
        
        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;
        
        const gain = audioContext.createGain();
        gain.gain.setValueAtTime(velocity * 0.3, startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.05);
        
        noise.connect(gain);
        gain.connect(audioContext.destination);
        
        noise.start(startTime);
      }
      
      console.log('ü•Å Web Audio Clap played');
    }

    // Message handler function that can be called directly
    function handleMessage(message) {
      try {
        console.log('üì® WebView received message type:', message.type);
        
        switch (message.type) {
          case 'init':
            init();
            break;
          case 'play_note':
            playTB303(message.note, message.velocity, message.accent, message.duration);
            break;
          case 'play_arp2600':
            playARP2600(message.note, message.velocity, message.accent, message.duration);
            break;
          case 'play_juno106':
            playJuno106(message.note, message.velocity, message.accent, message.duration);
            break;
          case 'play_minimoog':
            playMinimoog(message.note, message.velocity, message.accent, message.duration);
            break;
          case 'play_kick':
            playKick(message.velocity);
            break;
          case 'play_snare':
            playSnare(message.velocity);
            break;
          case 'play_hihat':
            playHihat(message.velocity, message.open);
            break;
          case 'play_clap':
            playClap(message.velocity);
            break;
          case 'update_params':
            updateParams(message.params);
            break;
          case 'stop_all':
            // Stop all active voices
            break;
        }
      } catch (error) {
        console.error('Message handling error:', error);
      }
    }
    
    // Also listen for postMessage (backup method)
    window.addEventListener('message', (event) => {
      try {
        const message = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
        handleMessage(message);
      } catch (error) {
        console.error('postMessage error:', error);
      }
    });

    // Auto-init on load
    if (document.readyState === 'complete') {
      init();
    } else {
      window.addEventListener('load', init);
    }

    // Signal ready
    sendMessage({ type: 'ready' });
  </script>
</body>
</html>
