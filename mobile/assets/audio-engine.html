<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HAOS Audio Engine</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #0f0;
      font-family: monospace;
      font-size: 10px;
    }
    #status {
      padding: 4px;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.9);
      border-bottom: 1px solid #0f0;
    }
  </style>
</head>
<body>
  <div id="status">üéµ HAOS Audio Engine v1.0</div>
  
  <script>
    console.log('üéµ HAOS Audio Engine loading...');
    
    // ========================================
    // AUDIO CONTEXT & NODES
    // ========================================
    
    let audioContext;
    let masterGain;
    let filterNode;
    let distortionNode;
    let reverbNode;
    let dryGain;
    let wetGain;
    let analyserNode;
    let delayNode;
    let feedbackGain;
    let compressorNode;
    
    // Waveform update interval
    let waveformInterval = null;
    
    // Synth parameters
    let synthParams = {
      cutoff: 1000,
      resonance: 5,
      attack: 0.01,
      release: 0.1,
      distortion: 0,
      reverb: 0,
      waveform: 'sawtooth',
    };
    
    // Drum parameters
    let kickParams = {
      pitch: 150,
      decay: 0.3,
    };
    
    let snareParams = {
      tone: 0.2,
    };
    
    let hihatParams = {
      decay: 0.05,
    };
    
    // ========================================
    // INITIALIZATION
    // ========================================
    
    function initAudio() {
      if (audioContext) {
        console.log('‚úÖ Audio already initialized');
        return;
      }
      
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        console.log('‚úÖ AudioContext created');
        
        // Master gain
        masterGain = audioContext.createGain();
        masterGain.gain.value = 0.7;
        
        // Filter (lowpass)
        filterNode = audioContext.createBiquadFilter();
        filterNode.type = 'lowpass';
        filterNode.frequency.value = synthParams.cutoff;
        filterNode.Q.value = synthParams.resonance;
        
        // Distortion
        distortionNode = audioContext.createWaveShaper();
        distortionNode.curve = makeDistortionCurve(0);
        distortionNode.oversample = '4x';
        
        // Reverb (convolver)
        reverbNode = audioContext.createConvolver();
        createReverbImpulse();
        
        // Dry/Wet mix for reverb
        dryGain = audioContext.createGain();
        wetGain = audioContext.createGain();
        dryGain.gain.value = 1;
        wetGain.gain.value = 0;
        
        // Delay
        delayNode = audioContext.createDelay(2.0);
        feedbackGain = audioContext.createGain();
        delayNode.delayTime.value = 0.5;
        feedbackGain.gain.value = 0.4;
        
        // Compressor
        compressorNode = audioContext.createDynamicsCompressor();
        compressorNode.threshold.value = -24;
        compressorNode.knee.value = 30;
        compressorNode.ratio.value = 12;
        compressorNode.attack.value = 0.003;
        compressorNode.release.value = 0.25;
        
        // Analyser for visualization
        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 2048;
        analyserNode.smoothingTimeConstant = 0.8;
        
        // Connect chain: filter ‚Üí distortion ‚Üí (dry + reverb) ‚Üí compressor ‚Üí master ‚Üí analyser ‚Üí destination
        filterNode.connect(distortionNode);
        distortionNode.connect(dryGain);
        distortionNode.connect(reverbNode);
        reverbNode.connect(wetGain);
        dryGain.connect(compressorNode);
        wetGain.connect(compressorNode);
        compressorNode.connect(masterGain);
        masterGain.connect(analyserNode);
        analyserNode.connect(audioContext.destination);
        
        console.log('‚úÖ Audio engine initialized');
        updateStatus('‚úÖ Audio Ready');
        
        // Notify React Native that we're ready
        sendMessage('ready', { sampleRate: audioContext.sampleRate });
        
      } catch (error) {
        console.error('‚ùå Audio initialization failed:', error);
        updateStatus('‚ùå Audio Failed');
        sendMessage('error', { message: error.message });
      }
    }
    
    // ========================================
    // DISTORTION CURVE
    // ========================================
    
    function makeDistortionCurve(amount) {
      const samples = 44100;
      const curve = new Float32Array(samples);
      const deg = Math.PI / 180;
      
      for (let i = 0; i < samples; i++) {
        const x = (i * 2) / samples - 1;
        curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
      }
      
      return curve;
    }
    
    // ========================================
    // REVERB IMPULSE RESPONSE
    // ========================================
    
    function createReverbImpulse() {
      const duration = 2;
      const decay = 2;
      const rate = audioContext.sampleRate;
      const length = rate * duration;
      const impulse = audioContext.createBuffer(2, length, rate);
      
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
      }
      
      reverbNode.buffer = impulse;
      console.log('‚úÖ Reverb impulse created');
    }
    
    // ========================================
    // DRUM SYNTHESIS
    // ========================================
    
    function playKick(params = {}) {
      initAudio();
      
      // Resume audio context if suspended (required on iOS)
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          console.log('‚úÖ AudioContext resumed');
        });
      }
      
      const pitch = params.pitch || kickParams.pitch;
      const decay = params.decay || kickParams.decay;
      const velocity = params.velocity !== undefined ? params.velocity : 1.0;
      
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.type = 'sine';
      osc.frequency.setValueAtTime(pitch, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
      
      gain.gain.setValueAtTime(velocity, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + decay);
      
      osc.connect(gain);
      gain.connect(filterNode);
      
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + decay);
      
      console.log('ü•Å Kick', { pitch, decay, velocity });
      sendMessage('soundPlayed', { sound: 'kick', pitch, decay, velocity });
    }
    
    function playSnare(params = {}) {
      initAudio();
      
      // Resume audio context if suspended (required on iOS)
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
      
      const tone = params.tone || snareParams.tone;
      const velocity = params.velocity !== undefined ? params.velocity : 1.0;
      
      // Noise component
      const noise = audioContext.createBufferSource();
      const buffer = audioContext.createBuffer(1, audioContext.sampleRate * tone, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      noise.buffer = buffer;
      
      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(0.5 * velocity, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + tone);
      
      noise.connect(gain);
      gain.connect(filterNode);
      
      noise.start(audioContext.currentTime);
      
      console.log('ü•Å Snare', { tone, velocity });
      sendMessage('soundPlayed', { sound: 'snare', tone, velocity });
    }
    
    function playHiHat(params = {}) {
      initAudio();
      
      // Resume audio context if suspended (required on iOS)
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
      
      const decay = params.decay || hihatParams.decay;
      const velocity = params.velocity !== undefined ? params.velocity : 1.0;
      
      // High-frequency noise
      const noise = audioContext.createBufferSource();
      const buffer = audioContext.createBuffer(1, audioContext.sampleRate * decay, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      noise.buffer = buffer;
      
      // High-pass filter
      const highpass = audioContext.createBiquadFilter();
      highpass.type = 'highpass';
      highpass.frequency.value = 7000;
      
      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(0.3 * velocity, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + decay);
      
      noise.connect(highpass);
      highpass.connect(gain);
      gain.connect(filterNode);
      
      noise.start(audioContext.currentTime);
      
      console.log('üîî HiHat', { decay, velocity });
      sendMessage('soundPlayed', { sound: 'hihat', decay, velocity });
    }
    
    function playClap() {
      initAudio();
      
      // Multiple short noise bursts
      const times = [0, 0.015, 0.030];
      times.forEach(offset => {
        const noise = audioContext.createBufferSource();
        const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < buffer.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        noise.buffer = buffer;
        
        const gain = audioContext.createGain();
        gain.gain.setValueAtTime(0.4, audioContext.currentTime + offset);
        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + offset + 0.05);
        
        noise.connect(gain);
        gain.connect(filterNode);
        noise.start(audioContext.currentTime + offset);
      });
      
      console.log('üëè Clap');
      sendMessage('soundPlayed', { sound: 'clap' });
    }
    
    function playCowbell(params = {}) {
      initAudio();
      
      const velocity = params.velocity || 1.0;
      
      // Classic TR-808 Cowbell: Two square waves at 540Hz and 800Hz
      const osc1 = audioContext.createOscillator();
      const osc2 = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const bandpass = audioContext.createBiquadFilter();
      
      osc1.type = 'square';
      osc1.frequency.value = 540;
      osc2.type = 'square';
      osc2.frequency.value = 800;
      
      bandpass.type = 'bandpass';
      bandpass.frequency.value = 800;
      bandpass.Q.value = 1.0;
      
      const now = audioContext.currentTime;
      gain.gain.setValueAtTime(0.3 * velocity, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
      
      osc1.connect(gain);
      osc2.connect(gain);
      gain.connect(bandpass);
      bandpass.connect(filterNode);
      
      osc1.start(now);
      osc2.start(now);
      osc1.stop(now + 0.5);
      osc2.stop(now + 0.5);
      
      console.log('üîî Cowbell', { velocity });
      sendMessage('soundPlayed', { sound: 'cowbell', velocity });
    }
    
    function playCymbal(params = {}) {
      initAudio();
      
      const velocity = params.velocity || 1.0;
      
      // TR-808 Cymbal: Multiple metallic oscillators
      const oscillators = [
        { freq: 296, amp: 0.15 },
        { freq: 414, amp: 0.15 },
        { freq: 587, amp: 0.12 },
        { freq: 845, amp: 0.10 },
        { freq: 1108, amp: 0.08 },
        { freq: 1316, amp: 0.05 }
      ];
      
      const now = audioContext.currentTime;
      const masterGain = audioContext.createGain();
      const highpass = audioContext.createBiquadFilter();
      
      highpass.type = 'highpass';
      highpass.frequency.value = 4000;
      highpass.Q.value = 1.0;
      
      masterGain.gain.setValueAtTime(0.2 * velocity, now);
      masterGain.gain.exponentialRampToValueAtTime(0.01, now + 1.2);
      
      oscillators.forEach(({ freq, amp }) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        osc.type = 'square';
        osc.frequency.value = freq;
        gain.gain.value = amp;
        
        osc.connect(gain);
        gain.connect(masterGain);
        
        osc.start(now);
        osc.stop(now + 1.2);
      });
      
      masterGain.connect(highpass);
      highpass.connect(filterNode);
      
      console.log('ü•Å Cymbal', { velocity });
      sendMessage('soundPlayed', { sound: 'cymbal', velocity });
    }
    
    function playTom(params = {}) {
      initAudio();
      
      const velocity = params.velocity || 1.0;
      const pitch = params.pitch || 120;
      const decay = params.decay || 0.4;
      
      // Tom: Pitched oscillator with fast pitch decay
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const noise = audioContext.createBufferSource();
      const noiseGain = audioContext.createGain();
      
      const now = audioContext.currentTime;
      
      // Tone oscillator
      osc.type = 'sine';
      osc.frequency.setValueAtTime(pitch * 2, now);
      osc.frequency.exponentialRampToValueAtTime(pitch, now + 0.05);
      
      gain.gain.setValueAtTime(0.7 * velocity, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + decay);
      
      // Add some noise for attack
      const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.1;
      }
      noise.buffer = buffer;
      
      noiseGain.gain.setValueAtTime(0.3 * velocity, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
      
      osc.connect(gain);
      noise.connect(noiseGain);
      gain.connect(filterNode);
      noiseGain.connect(filterNode);
      
      osc.start(now);
      noise.start(now);
      osc.stop(now + decay);
      
      console.log('ü•Å Tom', { pitch, decay, velocity });
      sendMessage('soundPlayed', { sound: 'tom', pitch, decay, velocity });
    }
    
    // ========================================
    // BASS/SYNTH SYNTHESIS
    // ========================================
    
    function playBass(params = {}) {
      initAudio();
      
      const frequency = params.frequency || 130.81;
      const duration = params.duration || 0.2;
      
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.type = synthParams.waveform;
      osc.frequency.value = frequency;
      
      const attack = synthParams.attack;
      const release = synthParams.release;
      
      gain.gain.setValueAtTime(0, audioContext.currentTime);
      gain.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + attack);
      gain.gain.setValueAtTime(0.5, audioContext.currentTime + duration - release);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      osc.connect(gain);
      gain.connect(filterNode);
      
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + duration);
      
      console.log('üé∏ Bass', { frequency, duration });
      sendMessage('soundPlayed', { sound: 'bass', frequency, duration });
    }
    
    function playSynthNote(params = {}) {
      initAudio();
      
      const frequency = params.frequency || 440;
      const duration = params.duration || 0.5;
      
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.type = synthParams.waveform;
      osc.frequency.value = frequency;
      
      const attack = synthParams.attack;
      const release = synthParams.release;
      
      gain.gain.setValueAtTime(0, audioContext.currentTime);
      gain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + attack);
      gain.gain.setValueAtTime(0.3, audioContext.currentTime + duration - release);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      osc.connect(gain);
      gain.connect(filterNode);
      
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + duration);
      
      console.log('üéπ Synth', { frequency, duration });
      sendMessage('soundPlayed', { sound: 'synth', frequency, duration });
    }
    
    // ========================================
    // CLASSIC SYNTHESIZER ENGINES
    // ========================================
    
    /**
     * Piano - Grand/Rhodes/Upright with harmonics
     * Multiple oscillators to simulate piano harmonics
     */
    function playPiano(params = {}) {
      initAudio();
      
      const frequency = params.frequency || 440;
      const duration = params.duration || 0.5;
      const velocity = params.velocity || 1.0;
      const pianoType = params.pianoType || 'grand';
      const reverb = params.reverb !== undefined ? params.reverb : 0.3;
      const brightness = params.brightness !== undefined ? params.brightness : 0.5;
      
      const now = audioContext.currentTime;
      
      // Piano characteristics per type
      const pianoSettings = {
        grand: { harmonics: [1, 2, 3, 4, 5], attack: 0.003, decay: 0.15, sustain: 0.3, release: 0.4, brightnessBoost: 1.2 },
        rhodes: { harmonics: [1, 2, 3, 5, 6], attack: 0.001, decay: 0.08, sustain: 0.6, release: 0.25, brightnessBoost: 0.9 },
        upright: { harmonics: [1, 2, 3, 4], attack: 0.005, decay: 0.12, sustain: 0.4, release: 0.35, brightnessBoost: 1.0 },
      };
      
      const settings = pianoSettings[pianoType] || pianoSettings.grand;
      
      // Create multiple oscillators for harmonics
      const oscillators = [];
      const gains = [];
      
      settings.harmonics.forEach((harmonic, index) => {
        const osc = audioContext.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = frequency * harmonic;
        
        const gain = audioContext.createGain();
        // Decay harmonic volume with index (fundamental loudest)
        const harmonicVolume = velocity * Math.pow(0.5, index) * settings.brightnessBoost * brightness;
        gain.gain.value = harmonicVolume;
        
        osc.connect(gain);
        oscillators.push(osc);
        gains.push(gain);
      });
      
      // Master piano gain with ADSR
      const pianoGain = audioContext.createGain();
      const sustainLevel = settings.sustain * velocity;
      
      pianoGain.gain.setValueAtTime(0, now);
      pianoGain.gain.linearRampToValueAtTime(velocity, now + settings.attack);
      pianoGain.gain.exponentialRampToValueAtTime(Math.max(sustainLevel, 0.01), now + settings.attack + settings.decay);
      pianoGain.gain.setValueAtTime(Math.max(sustainLevel, 0.01), now + duration - settings.release);
      pianoGain.gain.exponentialRampToValueAtTime(0.01, now + duration + settings.release);
      
      // Connect harmonics to master piano gain
      gains.forEach(gain => gain.connect(pianoGain));
      
      // Apply reverb if enabled
      if (reverb > 0.1) {
        const reverbWet = audioContext.createGain();
        const reverbDry = audioContext.createGain();
        reverbWet.gain.value = reverb;
        reverbDry.gain.value = 1 - reverb * 0.5;
        
        pianoGain.connect(reverbWet);
        pianoGain.connect(reverbDry);
        reverbWet.connect(convolver);
        reverbWet.connect(filterNode);
        reverbDry.connect(filterNode);
      } else {
        pianoGain.connect(filterNode);
      }
      
      // Start oscillators
      oscillators.forEach(osc => {
        osc.start(now);
        osc.stop(now + duration + settings.release);
      });
      
      console.log(`üéπ Piano ${pianoType}:`, { frequency, duration, velocity });
      sendMessage('soundPlayed', { sound: 'piano', type: pianoType, frequency, duration });
    }
    
    /**
     * ARP 2600 - Semi-modular 3-oscillator synth
     * Features: Dual VCO + LFO, 24dB ladder filter, ring mod capability
     */
    function playARP2600(params = {}) {
      initAudio();
      
      const frequency = params.frequency || 440;
      const duration = params.duration || 0.5;
      const velocity = params.velocity || 1.0;
      const detune = params.detune || 0.02; // Slight detune for thickness
      
      // Get parameters from UI (with fallbacks to defaults)
      const osc1Level = params.osc1Level !== undefined ? params.osc1Level : 0.5;
      const osc2Level = params.osc2Level !== undefined ? params.osc2Level : 0.5;
      const osc3Level = params.osc3Level !== undefined ? params.osc3Level : 0.0;
      const osc3Detune = params.osc3Detune !== undefined ? params.osc3Detune : -12;
      const filterCutoff = params.filterCutoff !== undefined ? params.filterCutoff : 2000;
      const filterResonance = params.filterResonance !== undefined ? params.filterResonance : 18;
      const attack = params.attack !== undefined ? params.attack : 0.05;
      const decay = params.decay !== undefined ? params.decay : 0.1;
      const sustain = params.sustain !== undefined ? params.sustain : 0.7;
      const release = params.release !== undefined ? params.release : 0.3;
      
      // LFO parameters (NEW!)
      const lfoRate = params.lfoRate !== undefined ? params.lfoRate : 5; // Hz
      const lfoDepth = params.lfoDepth !== undefined ? params.lfoDepth : 0.5; // 0-1
      const lfoToPitch = params.lfoToPitch !== undefined ? params.lfoToPitch : true; // Pitch modulation
      const lfoToFilter = params.lfoToFilter !== undefined ? params.lfoToFilter : false; // Filter modulation
      const lfoToAmp = params.lfoToAmp !== undefined ? params.lfoToAmp : false; // Amplitude modulation (tremolo)
      
      const now = audioContext.currentTime;
      
      // VCO 1 (Sawtooth - bright)
      const vco1 = audioContext.createOscillator();
      vco1.type = 'sawtooth';
      vco1.frequency.value = frequency;
      vco1.detune.value = -detune * 100; // Cents
      
      // VCO 2 (Square - harmonics)
      const vco2 = audioContext.createOscillator();
      vco2.type = 'square';
      vco2.frequency.value = frequency;
      vco2.detune.value = detune * 100; // Opposite detune for width
      
      // VCO 3 (Sine - sub bass or high pitch based on osc3Detune)
      const vco3 = audioContext.createOscillator();
      vco3.type = 'sine';
      vco3.frequency.value = frequency * Math.pow(2, osc3Detune / 12); // Semitones to frequency ratio
      
      // LFO for modulation (NEW: configurable rate and depth!)
      const lfo = audioContext.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = lfoRate; // User-controllable rate
      
      // LFO Gain for depth control
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = lfoDepth * 20; // Vibrato depth (scaled)
      
      lfo.connect(lfoGain);
      
      // Connect LFO to pitch (vibrato) if enabled
      if (lfoToPitch) {
        lfoGain.connect(vco1.frequency);
        lfoGain.connect(vco2.frequency);
      }
      
      // NEW: LFO ‚Üí Filter modulation (filter sweep/wobble)
      const lfoFilterGain = audioContext.createGain();
      if (lfoToFilter) {
        lfoFilterGain.gain.value = lfoDepth * filterCutoff * 0.3; // Modulate ¬±30% of cutoff
        lfo.connect(lfoFilterGain);
        lfoFilterGain.connect(arpFilter.frequency);
      }
      
      // NEW: LFO ‚Üí Amplitude modulation (tremolo)
      const lfoAmpGain = audioContext.createGain();
      if (lfoToAmp) {
        lfoAmpGain.gain.value = lfoDepth * 0.3; // Modulate ¬±30% of amplitude
        lfo.connect(lfoAmpGain);
        lfoAmpGain.connect(vca.gain);
      }
      
      // Mixer with UI-controlled levels
      const vco1Gain = audioContext.createGain();
      const vco2Gain = audioContext.createGain();
      const vco3Gain = audioContext.createGain();
      vco1Gain.gain.value = osc1Level * velocity;
      vco2Gain.gain.value = osc2Level * velocity;
      vco3Gain.gain.value = osc3Level * velocity;
      
      // 24dB Ladder filter (Moog-style) with UI-controlled cutoff and resonance
      const arpFilter = audioContext.createBiquadFilter();
      arpFilter.type = 'lowpass';
      arpFilter.frequency.value = filterCutoff;
      arpFilter.Q.value = filterResonance; // UI-controlled resonance
      
      // Filter envelope modulation with UI-controlled envelope
      const filterEnvAmount = filterCutoff * 0.5; // Envelope modulates up to 50% of cutoff
      arpFilter.frequency.setValueAtTime(filterCutoff * 0.4, now);
      arpFilter.frequency.exponentialRampToValueAtTime(filterCutoff + filterEnvAmount, now + attack);
      arpFilter.frequency.exponentialRampToValueAtTime(filterCutoff * (0.4 + sustain * 0.6), now + attack + decay);
      arpFilter.frequency.setValueAtTime(filterCutoff * (0.4 + sustain * 0.6), now + duration - release);
      arpFilter.frequency.exponentialRampToValueAtTime(filterCutoff * 0.4, now + duration);
      
      // VCA (Voltage Controlled Amplifier) with UI-controlled ADSR envelope
      const vca = audioContext.createGain();
      const maxVelocity = velocity * 0.7;
      const sustainLevel = maxVelocity * sustain;
      vca.gain.setValueAtTime(0, now);
      vca.gain.linearRampToValueAtTime(maxVelocity, now + attack); // Attack
      vca.gain.exponentialRampToValueAtTime(Math.max(sustainLevel, 0.01), now + attack + decay); // Decay
      vca.gain.setValueAtTime(Math.max(sustainLevel, 0.01), now + duration - release); // Sustain
      vca.gain.exponentialRampToValueAtTime(0.01, now + duration + release); // Release
      
      // Connect audio graph (including VCO3)
      vco1.connect(vco1Gain);
      vco2.connect(vco2Gain);
      vco3.connect(vco3Gain);
      vco1Gain.connect(arpFilter);
      vco2Gain.connect(arpFilter);
      vco3Gain.connect(arpFilter);
      arpFilter.connect(vca);
      vca.connect(filterNode);
      
      // Start oscillators
      vco1.start(now);
      vco2.start(now);
      vco3.start(now);
      lfo.start(now);
      
      // Stop oscillators
      vco1.stop(now + duration + release);
      vco2.stop(now + duration + release);
      vco3.stop(now + duration + release);
      lfo.stop(now + duration + release);
      
      console.log('üéõÔ∏è ARP 2600', { frequency, duration, velocity });
      sendMessage('soundPlayed', { sound: 'arp2600', frequency, duration });
    }
    
    /**
     * Roland Juno-106 - DCO synth with chorus
     * Features: DCO + Sub osc, HPF + VCF, built-in chorus
     */
    function playJuno106(params = {}) {
      initAudio();
      
      const frequency = params.frequency || 440;
      const duration = params.duration || 0.5;
      const velocity = params.velocity || 1.0;
      const chorusEnabled = params.chorus !== false; // Default on
      
      const now = audioContext.currentTime;
      
      // DCO (Digitally Controlled Oscillator - more stable than VCO)
      const dco = audioContext.createOscillator();
      dco.type = 'sawtooth';
      dco.frequency.value = frequency;
      
      // Sub oscillator (1 octave down)
      const sub = audioContext.createOscillator();
      sub.type = 'square';
      sub.frequency.value = frequency / 2;
      
      // Mixer
      const dcoGain = audioContext.createGain();
      const subGain = audioContext.createGain();
      dcoGain.gain.value = 0.6;
      subGain.gain.value = 0.3;
      
      // HPF (High-pass filter before VCF)
      const hpf = audioContext.createBiquadFilter();
      hpf.type = 'highpass';
      hpf.frequency.value = 50; // Remove subsonic rumble
      hpf.Q.value = 0.7;
      
      // VCF (Low-pass filter with resonance)
      const vcf = audioContext.createBiquadFilter();
      vcf.type = 'lowpass';
      vcf.frequency.value = 1500;
      vcf.Q.value = 5;
      
      // Filter envelope
      vcf.frequency.setValueAtTime(800, now);
      vcf.frequency.exponentialRampToValueAtTime(3000, now + 0.05);
      vcf.frequency.exponentialRampToValueAtTime(1500, now + 0.15);
      vcf.frequency.setValueAtTime(1500, now + duration - 0.1);
      
      // VCA
      const vca = audioContext.createGain();
      vca.gain.setValueAtTime(0, now);
      vca.gain.linearRampToValueAtTime(velocity * 0.5, now + 0.02);
      vca.gain.exponentialRampToValueAtTime(velocity * 0.4, now + 0.1);
      vca.gain.setValueAtTime(velocity * 0.4, now + duration - 0.15);
      vca.gain.exponentialRampToValueAtTime(0.01, now + duration);
      
      // Chorus effect (iconic Juno sound)
      let chorusOutput = vca;
      if (chorusEnabled) {
        // Chorus I (subtle)
        const chorus1Delay = audioContext.createDelay();
        chorus1Delay.delayTime.value = 0.02;
        
        const chorus1LFO = audioContext.createOscillator();
        chorus1LFO.type = 'sine';
        chorus1LFO.frequency.value = 0.7; // Hz
        
        const chorus1LFOGain = audioContext.createGain();
        chorus1LFOGain.gain.value = 0.002; // Depth
        
        chorus1LFO.connect(chorus1LFOGain);
        chorus1LFOGain.connect(chorus1Delay.delayTime);
        
        const chorusMix = audioContext.createGain();
        chorusMix.gain.value = 0.5;
        
        vca.connect(chorus1Delay);
        chorus1Delay.connect(chorusMix);
        vca.connect(chorusMix); // Dry signal
        
        chorus1LFO.start(now);
        chorus1LFO.stop(now + duration);
        
        chorusOutput = chorusMix;
      }
      
      // Connect audio graph
      dco.connect(dcoGain);
      sub.connect(subGain);
      dcoGain.connect(hpf);
      subGain.connect(hpf);
      hpf.connect(vcf);
      vcf.connect(vca);
      chorusOutput.connect(filterNode);
      
      // Start oscillators
      dco.start(now);
      sub.start(now);
      
      // Stop oscillators
      dco.stop(now + duration);
      sub.stop(now + duration);
      
      console.log('üéπ Juno-106', { frequency, duration, chorus: chorusEnabled });
      sendMessage('soundPlayed', { sound: 'juno106', frequency, duration });
    }
    
    /**
     * Minimoog Model D - 3-oscillator analog legend
     * Features: 3 VCO with 5 waveforms each, 24dB ladder filter, fat sound
     */
    function playMinimoog(params = {}) {
      initAudio();
      
      const frequency = params.frequency || 440;
      const duration = params.duration || 0.5;
      const velocity = params.velocity || 1.0;
      
      const now = audioContext.currentTime;
      
      // OSC 1 (Triangle - fundamental)
      const osc1 = audioContext.createOscillator();
      osc1.type = 'triangle';
      osc1.frequency.value = frequency;
      
      // OSC 2 (Sawtooth - harmonics)
      const osc2 = audioContext.createOscillator();
      osc2.type = 'sawtooth';
      osc2.frequency.value = frequency;
      osc2.detune.value = -5; // Slight detune for width
      
      // OSC 3 (Square - octave down for bass)
      const osc3 = audioContext.createOscillator();
      osc3.type = 'square';
      osc3.frequency.value = frequency / 2; // One octave down
      
      // Mixer (classic Minimoog balance)
      const osc1Gain = audioContext.createGain();
      const osc2Gain = audioContext.createGain();
      const osc3Gain = audioContext.createGain();
      osc1Gain.gain.value = 0.3;
      osc2Gain.gain.value = 0.4;
      osc3Gain.gain.value = 0.25;
      
      // 24dB Ladder filter (THE Moog sound)
      const moogFilter = audioContext.createBiquadFilter();
      moogFilter.type = 'lowpass';
      moogFilter.frequency.value = 1200;
      moogFilter.Q.value = 10; // High resonance for that "screaming" sound
      
      // Filter contour (envelope)
      const filterEnvAmount = 2000;
      moogFilter.frequency.setValueAtTime(600, now);
      moogFilter.frequency.exponentialRampToValueAtTime(2600, now + 0.03); // Fast attack
      moogFilter.frequency.exponentialRampToValueAtTime(1400, now + 0.12); // Decay
      moogFilter.frequency.setValueAtTime(1400, now + duration - 0.15); // Sustain
      moogFilter.frequency.exponentialRampToValueAtTime(600, now + duration); // Release
      
      // VCA with classic Minimoog envelope
      const vca = audioContext.createGain();
      vca.gain.setValueAtTime(0, now);
      vca.gain.linearRampToValueAtTime(velocity * 0.8, now + 0.01); // Fast attack
      vca.gain.exponentialRampToValueAtTime(velocity * 0.6, now + 0.08); // Decay
      vca.gain.setValueAtTime(velocity * 0.6, now + duration - 0.2); // Sustain
      vca.gain.exponentialRampToValueAtTime(0.01, now + duration); // Release
      
      // Connect audio graph
      osc1.connect(osc1Gain);
      osc2.connect(osc2Gain);
      osc3.connect(osc3Gain);
      osc1Gain.connect(moogFilter);
      osc2Gain.connect(moogFilter);
      osc3Gain.connect(moogFilter);
      moogFilter.connect(vca);
      vca.connect(filterNode);
      
      // Start oscillators
      osc1.start(now);
      osc2.start(now);
      osc3.start(now);
      
      // Stop oscillators
      osc1.stop(now + duration);
      osc2.stop(now + duration);
      osc3.stop(now + duration);
      
      console.log('üéπ Minimoog', { frequency, duration, velocity });
      sendMessage('soundPlayed', { sound: 'minimoog', frequency, duration });
    }
    
    /**
     * Roland TB-303 - Acid bass line machine
     * Features: Single VCO, resonant filter, accent, slide (glide)
     */
    function playTB303(params = {}) {
      initAudio();
      
      const frequency = params.frequency || 110;
      const duration = params.duration || 0.2;
      const velocity = params.velocity || 1.0;
      const accent = params.accent || false;
      const slide = params.slide || false;
      const slideFrom = params.slideFrom || frequency;
      
      const now = audioContext.currentTime;
      
      // VCO (Sawtooth or Square)
      const vco = audioContext.createOscillator();
      vco.type = params.waveform || 'sawtooth';
      
      // Slide (glide) effect
      if (slide && slideFrom !== frequency) {
        vco.frequency.setValueAtTime(slideFrom, now);
        vco.frequency.exponentialRampToValueAtTime(frequency, now + 0.05); // 50ms slide
      } else {
        vco.frequency.value = frequency;
      }
      
      // 24dB resonant filter (THE 303 sound)
      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.Q.value = 15; // Extreme resonance for acid squelch
      
      // Filter envelope (short, snappy)
      const baseFreq = accent ? 800 : 500;
      const envAmount = accent ? 3000 : 1500;
      filter.frequency.setValueAtTime(baseFreq, now);
      filter.frequency.exponentialRampToValueAtTime(baseFreq + envAmount, now + 0.015);
      filter.frequency.exponentialRampToValueAtTime(baseFreq + envAmount * 0.3, now + 0.08);
      filter.frequency.setValueAtTime(baseFreq + envAmount * 0.3, now + duration - 0.05);
      filter.frequency.exponentialRampToValueAtTime(baseFreq, now + duration);
      
      // VCA with accent
      const vca = audioContext.createGain();
      const maxGain = accent ? velocity * 0.8 : velocity * 0.5;
      vca.gain.setValueAtTime(0, now);
      vca.gain.linearRampToValueAtTime(maxGain, now + 0.005); // Ultra-fast attack
      vca.gain.exponentialRampToValueAtTime(maxGain * 0.7, now + 0.04);
      vca.gain.setValueAtTime(maxGain * 0.7, now + duration - 0.05);
      vca.gain.exponentialRampToValueAtTime(0.01, now + duration);
      
      // Connect audio graph
      vco.connect(filter);
      filter.connect(vca);
      vca.connect(filterNode);
      
      // Start oscillator
      vco.start(now);
      vco.stop(now + duration);
      
      console.log('üé∏ TB-303', { frequency, duration, accent, slide });
      sendMessage('soundPlayed', { sound: 'tb303', frequency, duration, accent, slide });
    }
    
    // ========================================
    // EFFECTS CONTROL
    // ========================================
    
    function setFilter(params = {}) {
      initAudio();
      filterNode.type = params.type || 'lowpass';
      filterNode.frequency.value = params.frequency || 1000;
      filterNode.Q.value = params.Q || 5;
      console.log('üéöÔ∏è Filter', params);
    }
    
    function setDistortion(params = {}) {
      initAudio();
      const amount = params.amount || 0;
      synthParams.distortion = amount;
      distortionNode.curve = makeDistortionCurve(amount / 100 * 50);
      console.log('‚ö° Distortion', amount);
    }
    
    function setReverb(params = {}) {
      initAudio();
      const amount = params.amount || 0;
      synthParams.reverb = amount;
      const wetAmount = amount / 100;
      wetGain.gain.value = wetAmount;
      dryGain.gain.value = 1 - (wetAmount * 0.5);
      console.log('üåä Reverb', amount);
    }
    
    function setDelay(params = {}) {
      initAudio();
      delayNode.delayTime.value = params.time || 0.5;
      feedbackGain.gain.value = params.feedback || 0.4;
      console.log('üîÅ Delay', params);
    }
    
    function setCompression(params = {}) {
      initAudio();
      compressorNode.threshold.value = params.threshold || -24;
      compressorNode.ratio.value = params.ratio || 12;
      compressorNode.attack.value = params.attack || 0.003;
      compressorNode.release.value = params.release || 0.25;
      console.log('üì¶ Compression', params);
    }
    
    // ========================================
    // SYNTH PARAMETERS
    // ========================================
    
    function updateSynthParam(params = {}) {
      const { param, value } = params;
      if (synthParams.hasOwnProperty(param)) {
        synthParams[param] = value;
        console.log(`üéõÔ∏è ${param}: ${value}`);
        
        // Update audio nodes
        if (param === 'cutoff' && filterNode) {
          filterNode.frequency.value = value;
        } else if (param === 'resonance' && filterNode) {
          filterNode.Q.value = value;
        } else if (param === 'distortion' && distortionNode) {
          distortionNode.curve = makeDistortionCurve(value / 100 * 50);
        } else if (param === 'reverb' && wetGain && dryGain) {
          const wetAmount = value / 100;
          wetGain.gain.value = wetAmount;
          dryGain.gain.value = 1 - (wetAmount * 0.5);
        }
      }
    }
    
    function setADSR(params = {}) {
      synthParams.attack = params.attack || 0.01;
      synthParams.decay = params.decay || 0.1;
      synthParams.sustain = params.sustain || 0.7;
      synthParams.release = params.release || 0.1;
      console.log('üìà ADSR', params);
    }
    
    function setWaveform(params = {}) {
      synthParams.waveform = params.waveform || 'sawtooth';
      console.log('„Ä∞Ô∏è Waveform', params.waveform);
    }
    
    // ========================================
    // VISUALIZATION
    // ========================================
    
    function getWaveform() {
      if (!analyserNode) {
        initAudio();
      }
      
      const bufferLength = analyserNode.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      analyserNode.getByteTimeDomainData(dataArray);
      
      // Downsample to 50 bars for mobile
      const bars = 50;
      const step = Math.floor(bufferLength / bars);
      const waveform = [];
      
      for (let i = 0; i < bars; i++) {
        const index = i * step;
        const normalized = (dataArray[index] - 128) / 128;
        waveform.push(Math.abs(normalized));
      }
      
      sendMessage('waveform', { data: waveform });
    }
    
    function getAudioLevel() {
      if (!analyserNode) {
        initAudio();
        sendMessage('audioLevel', { db: -Infinity });
        return;
      }
      
      const bufferLength = analyserNode.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      analyserNode.getByteTimeDomainData(dataArray);
      
      // Calculate RMS
      let sum = 0;
      for (let i = 0; i < bufferLength; i++) {
        const normalized = (dataArray[i] - 128) / 128;
        sum += normalized * normalized;
      }
      const rms = Math.sqrt(sum / bufferLength);
      const db = rms > 0 ? 20 * Math.log10(rms) : -Infinity;
      
      sendMessage('audioLevel', { db, rms });
    }
    
    function startWaveformUpdates(params = {}) {
      const interval = params.interval || 50;
      
      if (waveformInterval) {
        clearInterval(waveformInterval);
      }
      
      waveformInterval = setInterval(() => {
        getWaveform();
        getAudioLevel();
      }, interval);
      
      console.log('üìä Waveform updates started', interval + 'ms');
    }
    
    function stopWaveformUpdates() {
      if (waveformInterval) {
        clearInterval(waveformInterval);
        waveformInterval = null;
        console.log('üìä Waveform updates stopped');
      }
    }
    
    // ========================================
    // MASTER CONTROLS
    // ========================================
    
    function setMasterVolume(params = {}) {
      initAudio();
      masterGain.gain.value = params.volume || 0.7;
      console.log('üîä Master volume', params.volume);
    }
    
    // ========================================
    // COMMUNICATION
    // ========================================
    
    function sendMessage(type, payload = {}) {
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({ type, payload }));
      } else {
        console.log('üì§', type, payload);
      }
    }
    
    function updateStatus(text) {
      document.getElementById('status').textContent = text;
    }
    
    // ========================================
    // COMMAND PROCESSOR
    // ========================================
    
    window.processCommand = function(message) {
      try {
        const { command, params } = message;
        console.log('üì• Command:', command, params);
        
        switch (command) {
          case 'initAudio':
            initAudio();
            break;
          case 'setMasterVolume':
            setMasterVolume(params);
            break;
          case 'playKick':
            playKick(params);
            break;
          case 'playSnare':
            playSnare(params);
            break;
          case 'playHiHat':
            playHiHat(params);
            break;
          case 'playClap':
            playClap();
            break;
          case 'playCowbell':
            playCowbell(params);
            break;
          case 'playCymbal':
            playCymbal(params);
            break;
          case 'playTom':
            playTom(params);
            break;
          case 'playBass':
            playBass(params);
            break;
          case 'playSynthNote':
            playSynthNote(params);
            break;
          case 'playPiano':
            playPiano(params);
            break;
          case 'playARP2600':
            playARP2600(params);
            break;
          case 'playJuno106':
            playJuno106(params);
            break;
          case 'playMinimoog':
            playMinimoog(params);
            break;
          case 'playTB303':
            playTB303(params);
            break;
          case 'setFilter':
            setFilter(params);
            break;
          case 'setDistortion':
            setDistortion(params);
            break;
          case 'setReverb':
            setReverb(params);
            break;
          case 'setDelay':
            setDelay(params);
            break;
          case 'setCompression':
            setCompression(params);
            break;
          case 'updateSynthParam':
            updateSynthParam(params);
            break;
          case 'setADSR':
            setADSR(params);
            break;
          case 'setWaveform':
            setWaveform(params);
            break;
          case 'getWaveform':
            getWaveform();
            break;
          case 'getAudioLevel':
            getAudioLevel();
            break;
          case 'startWaveformUpdates':
            startWaveformUpdates(params);
            break;
          case 'stopWaveformUpdates':
            stopWaveformUpdates();
            break;
          default:
            console.warn('‚ö†Ô∏è Unknown command:', command);
        }
      } catch (error) {
        console.error('‚ùå Command error:', error);
        sendMessage('error', { message: error.message, command: message.command });
      }
    };
    
    // ========================================
    // AUTO-INIT
    // ========================================
    
    // Auto-initialize on load
    window.addEventListener('load', () => {
      console.log('üéµ Audio engine loaded');
      updateStatus('‚è≥ Loading...');
      
      // Small delay to ensure everything is ready
      setTimeout(() => {
        initAudio();
      }, 100);
    });
    
    console.log('‚úÖ Audio engine script loaded');
  </script>
</body>
</html>
