<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HAOS.fm | TECHNO Workspace - Live Production Studio</title>
    
    <!-- Fonts - Technical Monospace -->
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Mono:wght@400;700&family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- i18n Translation System -->
    <script src="/js/i18n.js"></script>
    
    <!-- HAOS Knob Component -->
    <script src="/js/components/haos-knob.js"></script>
    
    <style>
        :root {
            /* Colors from sounds.html */
            --bg-dark: #050508;
            --bg-card: rgba(15, 15, 20, 0.8);
            --bg-glass: rgba(255, 255, 255, 0.03);
            --accent-orange: #FF6B35;
            --accent-gold: #D4AF37;
            --accent-cyan: #00D9FF;
            --accent-green: #39FF14;
            --accent-purple: #8B5CF6;
            --text-primary: #F4E8D8;
            --text-secondary: rgba(244, 232, 216, 0.6);
            --text-dim: rgba(244, 232, 216, 0.3);
            --border-subtle: rgba(255, 107, 53, 0.1);
            --border-glow: rgba(255, 107, 53, 0.3);
            
            /* Fonts - Updated with JetBrains Mono */
            --font-display: 'Bebas Neue', sans-serif;
            --font-mono: 'JetBrains Mono', 'Space Mono', monospace;
            --font-body: 'Inter', sans-serif;
            --font-technical: 'JetBrains Mono', 'Space Mono', monospace;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: var(--font-body);
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        /* Animated Background */
        .bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        .bg-gradient {
            position: absolute;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse 80% 50% at 20% 40%, rgba(255, 107, 53, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 80% 60%, rgba(0, 217, 255, 0.05) 0%, transparent 50%);
        }

        /* Navigation */
        .nav-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 15px 30px;
            background: rgba(5, 5, 8, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .nav-inner {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .nav-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            text-decoration: none;
        }
        
        .logo-icon {
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, var(--accent-orange), #CC5529);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }
        
        .logo-text {
            font-family: var(--font-display);
            font-size: 1.8rem;
            color: var(--text-primary);
            letter-spacing: 0.05em;
        }

        .nav-links {
            display: flex;
            gap: 8px;
        }
        
        .nav-link {
            padding: 10px 20px;
            background: var(--bg-glass);
            border: 1px solid var(--border-subtle);
            border-radius: 30px;
            color: var(--text-secondary);
            font-family: var(--font-mono);
            font-size: 0.8rem;
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        .nav-link:hover {
            border-color: var(--accent-orange);
            color: var(--accent-orange);
        }
        
        .nav-link.active {
            background: linear-gradient(135deg, var(--accent-orange), #CC5529);
            border-color: transparent;
            color: white;
        }

        /* Main Content */
        .main-content {
            padding-top: 90px;
            max-width: 1600px;
            margin: 0 auto;
            padding-left: 20px;
            padding-right: 20px;
        }

        /* Hero Section */
        .hero {
            text-align: center;
            padding: 40px 20px;
        }

        .hero-title {
            font-family: var(--font-display);
            font-size: clamp(3rem, 8vw, 6rem);
            line-height: 0.9;
            margin-bottom: 20px;
            background: linear-gradient(90deg, 
                #FF6B35 0%, 
                #F7931E 15%, 
                #FDC830 30%, 
                #D4AF37 45%, 
                #FFD700 60%, 
                #F7931E 75%, 
                #FF6B35 100%
            );
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s linear infinite;
        }
        
        @keyframes shimmer {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        .hero-subtitle {
            font-family: var(--font-mono);
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 30px;
        }

        /* Transport Controls */
        .transport-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            margin-bottom: 30px;
        }

        .transport-btn {
            position: relative;
            padding: 14px 32px;
            background: linear-gradient(135deg, var(--accent-orange) 0%, #FF8C35 50%, var(--accent-orange) 100%);
            background-size: 200% 100%;
            border: 2px solid transparent;
            border-radius: 50px;
            color: white;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 4px 15px rgba(255, 107, 53, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -2px 0 rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }
        
        .transport-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }
        
        .transport-btn:hover::before {
            left: 100%;
        }

        .transport-btn:hover {
            transform: translateY(-3px) scale(1.02);
            background-position: 100% 0;
            box-shadow: 
                0 8px 30px rgba(255, 107, 53, 0.6),
                0 0 40px rgba(255, 107, 53, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .transport-btn:active {
            transform: translateY(-1px) scale(0.98);
            box-shadow: 
                0 2px 10px rgba(255, 107, 53, 0.4),
                inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .transport-btn.playing {
            background: linear-gradient(135deg, var(--accent-green) 0%, #4AFF14 50%, var(--accent-green) 100%);
            box-shadow: 
                0 4px 20px rgba(57, 255, 20, 0.4),
                0 0 30px rgba(57, 255, 20, 0.3);
            animation: pulse-btn 2s ease-in-out infinite;
        }
        
        @keyframes pulse-btn {
            0%, 100% { box-shadow: 0 4px 20px rgba(57, 255, 20, 0.4), 0 0 30px rgba(57, 255, 20, 0.3); }
            50% { box-shadow: 0 4px 30px rgba(57, 255, 20, 0.6), 0 0 50px rgba(57, 255, 20, 0.5); }
        }

        .bpm-display {
            padding: 12px 24px;
            background: var(--bg-glass);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            font-family: var(--font-technical);
            color: var(--accent-orange);
            font-size: 1.2rem;
            font-weight: 600;
            letter-spacing: 1px;
        }

        /* Live Technical Status */
        .tech-live-status {
            display: flex;
            gap: 1rem;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
        }

        .tech-live-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tech-live-label {
            font-family: var(--font-technical);
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tech-live-value {
            font-family: var(--font-technical);
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--accent-green);
            text-shadow: 0 0 6px rgba(57, 255, 20, 0.4);
            min-width: 50px;
        }

        .tech-live-value.active {
            animation: valueBlink 0.2s ease;
        }

        @keyframes valueBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; color: var(--accent-cyan); }
        }
        
        .dropdown {
            padding: 12px 20px;
            background: var(--bg-glass);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            font-family: var(--font-technical);
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            outline: none;
        }
        
        .dropdown:hover {
            border-color: var(--accent-orange);
        }
        
        .dropdown:focus {
            border-color: var(--accent-orange);
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.3);
        }
        
        .dropdown option {
            background: var(--bg-dark);
            color: var(--text-primary);
        }

        /* Workspace Grid */
        .workspace-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 40px;
        }

        /* Panel */
        .panel {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            padding: 24px;
            backdrop-filter: blur(10px);
        }

        .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .panel-icon {
            width: 40px;
            height: 40px;
            background: rgba(255, 107, 53, 0.15);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .panel-title {
            font-family: var(--font-display);
            font-size: 1.5rem;
            color: var(--text-primary);
            letter-spacing: 0.02em;
        }

        /* Sequencer Grid */
        .sequencer-track {
            margin-bottom: 20px;
        }

        .track-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .track-label {
            font-family: var(--font-mono);
            font-size: 0.9rem;
            color: var(--text-secondary);
            min-width: 80px;
        }

        .track-controls {
            display: flex;
            gap: 8px;
        }

        .track-btn {
            width: 36px;
            height: 36px;
            background: linear-gradient(145deg, rgba(255, 107, 53, 0.15), rgba(255, 107, 53, 0.05));
            border: 2px solid var(--border-subtle);
            border-radius: 10px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .track-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(255, 107, 53, 0.3), transparent);
            transform: translate(-50%, -50%);
            transition: width 0.3s ease, height 0.3s ease;
            border-radius: 50%;
        }
        
        .track-btn:hover::before {
            width: 100px;
            height: 100px;
        }

        .track-btn:hover {
            border-color: var(--accent-orange);
            color: var(--accent-orange);
            transform: scale(1.1);
            box-shadow: 
                0 4px 15px rgba(255, 107, 53, 0.4),
                0 0 20px rgba(255, 107, 53, 0.2);
        }
        
        .track-btn:active {
            transform: scale(0.95);
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.3);
        }

        .step-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 4px;
        }

        .step {
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-subtle);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .step:hover {
            background: rgba(255, 107, 53, 0.2);
            border-color: var(--accent-orange);
        }

        .step.active {
            background: var(--accent-orange);
            border-color: var(--accent-orange);
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.5);
        }

        .step.playing {
            background: var(--accent-green);
            animation: pulse 0.3s ease;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        /* Preset Browser */
        .preset-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .preset-item {
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-subtle);
            border-radius: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-item:hover {
            background: rgba(255, 107, 53, 0.1);
            border-color: var(--accent-orange);
        }

        .preset-name {
            font-family: var(--font-mono);
            font-size: 0.85rem;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .preset-info {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        /* Pattern Preset Buttons */
        .pattern-preset-btn {
            padding: 15px 12px;
            background: linear-gradient(145deg, rgba(57, 255, 20, 0.15), rgba(57, 255, 20, 0.05));
            border: 2px solid rgba(57, 255, 20, 0.3);
            border-radius: 12px;
            color: var(--text-secondary);
            font-family: var(--font-mono);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .pattern-preset-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(57, 255, 20, 0.4), transparent);
            transform: translate(-50%, -50%);
            transition: width 0.4s ease, height 0.4s ease;
            border-radius: 50%;
            z-index: 0;
        }

        .pattern-preset-btn:hover::before {
            width: 200px;
            height: 200px;
        }

        .pattern-preset-btn:hover {
            border-color: var(--accent-green);
            color: var(--accent-green);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 5px 20px rgba(57, 255, 20, 0.4),
                0 0 30px rgba(57, 255, 20, 0.2);
        }

        .pattern-preset-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .pattern-preset-btn.active {
            background: linear-gradient(135deg, var(--accent-green), #4AFF14);
            border-color: var(--accent-green);
            color: #000;
            font-weight: 700;
            box-shadow: 
                0 5px 25px rgba(57, 255, 20, 0.6),
                0 0 40px rgba(57, 255, 20, 0.4),
                inset 0 2px 10px rgba(255, 255, 255, 0.3);
            animation: patternPulse 2s ease-in-out infinite;
        }

        @keyframes patternPulse {
            0%, 100% { 
                box-shadow: 
                    0 5px 25px rgba(57, 255, 20, 0.6),
                    0 0 40px rgba(57, 255, 20, 0.4),
                    inset 0 2px 10px rgba(255, 255, 255, 0.3);
            }
            50% { 
                box-shadow: 
                    0 7px 35px rgba(57, 255, 20, 0.8),
                    0 0 60px rgba(57, 255, 20, 0.6),
                    inset 0 2px 10px rgba(255, 255, 255, 0.5);
            }
        }

        .pattern-preset-name {
            position: relative;
            z-index: 1;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .pattern-preset-bpm {
            position: relative;
            z-index: 1;
            font-size: 0.7rem;
            color: var(--accent-green);
            opacity: 0.8;
        }

        /* Responsive */
        @media (min-width: 768px) {
            .workspace-grid {
                grid-template-columns: 2fr 1fr;
            }
        }

        /* Tablet (Portrait) */
        @media (max-width: 1024px) {
            .main-content {
                padding-left: 15px;
                padding-right: 15px;
            }
            
            .transport-bar {
                gap: 10px;
            }
            
            .transport-btn {
                padding: 12px 20px;
                font-size: 0.8rem;
            }
        }

        /* Mobile (Landscape & Portrait) */
        @media (max-width: 768px) {
            .nav-links { 
                display: none; 
            }
            
            .nav-wrapper {
                padding: 12px 15px;
            }
            
            .logo-icon {
                width: 40px;
                height: 40px;
            }
            
            .logo-text {
                font-size: 1.5rem;
            }
            
            .main-content {
                padding-top: 70px;
                padding-left: 12px;
                padding-right: 12px;
            }
            
            .hero {
                padding: 25px 15px;
            }
            
            .hero-title { 
                font-size: 2.5rem; 
                margin-bottom: 15px;
            }
            
            .hero-subtitle {
                font-size: 0.85rem;
                margin-bottom: 20px;
            }
            
            .transport-bar { 
                flex-wrap: wrap;
                gap: 8px;
                padding: 15px;
            }
            
            .transport-btn {
                flex: 1;
                min-width: 120px;
                padding: 12px 16px;
                font-size: 0.75rem;
            }
            
            .dropdown {
                flex: 1;
                min-width: 140px;
                font-size: 0.75rem;
                padding: 10px 15px;
            }
            
            .panel {
                padding: 18px;
                border-radius: 15px;
            }
            
            .panel-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                margin-bottom: 15px;
            }
            
            .panel-title {
                font-size: 1.3rem;
            }
            
            /* Drum modifiers - stack vertically on mobile */
            .panel > div:first-of-type {
                grid-template-columns: 1fr 1fr !important;
                gap: 12px !important;
                padding: 12px !important;
            }
            
            .panel > div:first-of-type label {
                font-size: 0.65rem !important;
            }
            
            .track-header {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                margin-bottom: 8px;
            }
            
            .track-label {
                font-size: 0.8rem;
                min-width: 60px;
            }
            
            .track-btn {
                width: 34px;
                height: 34px;
                font-size: 0.8rem;
            }
            
            .step-grid { 
                gap: 2px;
            }
            
            .step {
                min-height: 32px;
                border-width: 1px;
                border-radius: 4px;
            }
            
            .sequencer-track {
                margin-bottom: 15px;
            }
            
            /* Synth knobs - 3 columns on mobile */
            .knob-container:nth-child(1), .knob-container:nth-child(2) {
                grid-column: span 1;
            }
            
            /* Preset filters */
            .panel > div:has(#categoryFilter) {
                grid-template-columns: 1fr !important;
            }
            
            .preset-list {
                max-height: 250px;
            }
            
            .preset-item {
                padding: 10px;
            }
            
            .preset-name {
                font-size: 0.8rem;
            }
            
            .preset-info {
                font-size: 0.65rem;
            }
        }
        
        /* Small Mobile */
        @media (max-width: 480px) {
            .hero-title {
                font-size: 2rem;
            }
            
            .transport-bar {
                padding: 12px;
            }
            
            .transport-btn {
                padding: 10px 14px;
                font-size: 0.7rem;
                min-width: 100px;
            }
            
            .dropdown {
                padding: 8px 12px;
                font-size: 0.7rem;
            }
            
            .panel {
                padding: 15px;
            }
            
            .panel-title {
                font-size: 1.2rem;
            }
            
            /* Drum modifiers - single column on very small screens */
            .panel > div:first-of-type {
                grid-template-columns: 1fr !important;
            }
            
            .step {
                min-height: 28px;
            }
            
            .step-grid {
                gap: 1.5px;
            }
            
            /* Synth knobs - 2 columns on small mobile */
            .panel:has(#knob-cutoff) > div {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 15px !important;
            }
            
            .knob {
                width: 60px;
                height: 60px;
            }
            
            .knob-label {
                font-size: 0.65rem;
            }
            
            .knob-value {
                font-size: 0.75rem;
            }
        }
        
        /* Touch-friendly enhancements */
        @media (hover: none) and (pointer: coarse) {
            .step {
                min-height: 40px;
            }
            
            .track-btn {
                width: 40px;
                height: 40px;
            }
            
            .transport-btn {
                padding: 14px 20px;
                min-height: 44px;
            }
            
            .dropdown {
                min-height: 44px;
            }
            
            .preset-item {
                padding: 12px;
                min-height: 44px;
            }
        }

        /* Knob Control */
        .knob-container {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .knob {
            width: 80px;
            height: 80px;
            margin: 0 auto 10px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 107, 53, 0.2), rgba(0, 0, 0, 0.4));
            border: 3px solid var(--border-subtle);
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .knob:hover {
            border-color: var(--accent-orange);
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.4);
        }
        
        .knob::before {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--accent-orange);
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.8);
            z-index: 2;
        }
        
        .knob::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 25px;
            background: linear-gradient(to bottom, var(--accent-orange), transparent);
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(255, 107, 53, 0.6);
        }
        
        .knob-label {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 5px;
        }
        
        .knob-value {
            font-family: var(--font-mono);
            font-size: 0.85rem;
            color: var(--accent-orange);
            font-weight: 600;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border-subtle); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent-orange); }
        
        /* Pitch Slider Styling */
        #pitchSlider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-green);
            cursor: pointer;
            border: 2px solid rgba(57, 255, 20, 0.8);
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.5);
            transition: all 0.2s ease;
        }
        
        #pitchSlider::-webkit-slider-thumb:hover {
            background: rgba(57, 255, 20, 1);
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.8);
            transform: scale(1.1);
        }
        
        #pitchSlider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-green);
            cursor: pointer;
            border: 2px solid rgba(57, 255, 20, 0.8);
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.5);
            transition: all 0.2s ease;
        }
        
        #pitchSlider::-moz-range-thumb:hover {
            background: rgba(57, 255, 20, 1);
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.8);
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <!-- Background -->
    <div class="bg-canvas">
        <div class="bg-gradient"></div>
        <canvas id="particleCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
    </div>

    <!-- Navigation -->
    <nav class="nav-wrapper">
        <div class="nav-inner">
            <a href="/" class="nav-logo">
                <div class="logo-icon">üéõÔ∏è</div>
                <span class="logo-text">HAOS.FM</span>
            </a>
            <div class="nav-links">
                <a href="/techno-workspace" class="nav-link active">TECHNO</a>
                <a href="/modular-workspace" class="nav-link">MODULAR</a>
                <a href="/builder" class="nav-link">BUILDER</a>
                <a href="/sounds" class="nav-link">SOUNDS</a>
                <!-- Language Toggle -->
                <button id="languageToggle" onclick="toggleLanguage()" 
                    style="background: linear-gradient(135deg, #FF6B35, #FF8C42); color: white; border: none; border-radius: 8px; padding: 6px 12px; font-family: var(--font-mono); font-size: 0.75rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease; margin-left: 10px;"
                    onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 15px rgba(255, 107, 53, 0.4)';"
                    onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                    üáµüá± PL
                </button>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Hero -->
        <section class="hero">
            <h1 class="hero-title" data-i18n="techno-hero-title">TECHNO WORKSPACE</h1>
            <p class="hero-subtitle" data-i18n="techno-hero-subtitle">Live Production Studio ‚Ä¢ 16-Step Sequencer ‚Ä¢ Real-time Synthesis</p>
            <button onclick="showKeyboardHelp()" style="margin-top: 10px; padding: 8px 16px; background: rgba(255, 107, 53, 0.1); border: 1px solid var(--border-subtle); border-radius: 20px; color: var(--text-secondary); font-family: var(--font-mono); font-size: 0.75rem; cursor: pointer;" data-i18n="techno-keyboard-shortcuts">
                ‚å®Ô∏è KEYBOARD SHORTCUTS
            </button>
        </section>

        <!-- Transport Controls -->
        <div class="transport-bar">
            <button class="transport-btn" id="playBtn" data-i18n="techno-play">
                <span style="margin-right: 8px;">‚ñ∂</span> PLAY
            </button>
            <button class="transport-btn" id="stopBtn" data-i18n="techno-stop">
                <span style="margin-right: 8px;">‚ñ†</span> STOP
            </button>
            
            <!-- BPM Knob -->
            <div style="display: flex; flex-direction: column; align-items: center;">
                <haos-knob 
                    id="bpmKnob"
                    name="BPM" 
                    min="60" 
                    max="200" 
                    value="135"
                    color="#FF6B35"
                    size="70"
                    sensitivity="0.5">
                </haos-knob>
            </div>
            
            <select class="dropdown" id="genreSelect" onchange="loadPattern(this.value)">
                <option value="">Select Pattern</option>
                <optgroup label="Electronic">
                    <option value="techno">TECHNO</option>
                    <option value="acid">ACID HOUSE</option>
                    <option value="minimal">MINIMAL</option>
                    <option value="industrial">INDUSTRIAL</option>
                    <option value="trance">TRANCE</option>
                    <option value="dubstep">DUBSTEP</option>
                </optgroup>
                <optgroup label="Hip-Hop">
                    <option value="hiphop">HIP-HOP</option>
                    <option value="trap">TRAP</option>
                    <option value="drill">DRILL</option>
                    <option value="boom-bap">BOOM BAP</option>
                    <option value="lofi">LO-FI</option>
                </optgroup>
                <optgroup label="Dance">
                    <option value="house">HOUSE</option>
                    <option value="dnb">DRUM & BASS</option>
                    <option value="breaks">BREAKBEAT</option>
                </optgroup>
            </select>
            
            <button class="transport-btn" id="saveBtn">
                <span style="margin-right: 8px;">üíæ</span> SAVE
            </button>
            
            <button class="transport-btn" id="loadBtn">
                <span style="margin-right: 8px;">ÔøΩ</span> LOAD
            </button>
            
            <button class="transport-btn" id="midiBtn" style="background: linear-gradient(135deg, var(--accent-purple) 0%, #7C3AED 50%, var(--accent-purple) 100%);">
                <span style="margin-right: 8px;">üéπ</span> MIDI
            </button>
            
            <button class="transport-btn" id="exportBtn" style="background: linear-gradient(135deg, var(--accent-cyan) 0%, #00B8D4 50%, var(--accent-cyan) 100%);">
                <span style="margin-right: 8px;">üíæ</span> EXPORT
            </button>

            <!-- Live Technical Status -->
            <div class="tech-live-status">
                <div class="tech-live-item">
                    <span class="tech-live-label">STEP</span>
                    <span class="tech-live-value" id="live-step">01</span>
                </div>
                <div class="tech-live-item">
                    <span class="tech-live-label">BAR</span>
                    <span class="tech-live-value" id="live-bar">1</span>
                </div>
                <div class="tech-live-item">
                    <span class="tech-live-label">CPU</span>
                    <span class="tech-live-value" id="live-cpu">12%</span>
                </div>
                <div class="tech-live-item">
                    <span class="tech-live-label">LAT</span>
                    <span class="tech-live-value" id="live-latency">5.8ms</span>
                </div>
            </div>
        </div>

        <!-- Export Dialog (hidden by default) -->
        <div id="exportDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(5, 5, 8, 0.98); padding: 30px; border-radius: 15px; border: 2px solid var(--accent-cyan); box-shadow: 0 10px 40px rgba(0, 217, 255, 0.3); z-index: 1000; max-width: 450px;">
            <h3 style="color: var(--accent-cyan); font-family: 'Bebas Neue', sans-serif; font-size: 28px; margin-bottom: 20px; text-align: center;">EXPORT AUDIO</h3>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; font-family: 'Space Mono', monospace; font-size: 0.8rem; color: var(--text-dim); margin-bottom: 8px;">FORMAT</label>
                <select id="exportFormat" style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid var(--accent-cyan); border-radius: 8px; color: white; font-family: 'Space Mono', monospace; font-size: 14px;">
                    <option value="audio/webm">WebM (recommended)</option>
                    <option value="audio/ogg">OGG</option>
                    <option value="wav-custom">WAV (44.1kHz 16-bit)</option>
                </select>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; font-family: 'Space Mono', monospace; font-size: 0.8rem; color: var(--text-dim); margin-bottom: 8px;">DURATION (bars)</label>
                <input type="number" id="exportBars" value="4" min="1" max="16" style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid var(--accent-cyan); border-radius: 8px; color: white; font-family: 'Space Mono', monospace; font-size: 14px;">
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 15px;">
                <button id="exportStartBtn" class="transport-btn" style="flex: 1; background: linear-gradient(135deg, var(--accent-cyan) 0%, #00B8D4 50%, var(--accent-cyan) 100%);">
                    START RECORDING
                </button>
                <button id="exportCloseBtn" class="transport-btn" style="flex: 1; background: linear-gradient(135deg, #666 0%, #888 50%, #666 100%);">
                    CLOSE
                </button>
            </div>
            
            <div id="exportStatus" style="padding: 12px; background: rgba(0, 217, 255, 0.1); border-radius: 5px; border: 1px solid var(--accent-cyan); color: var(--accent-cyan); font-family: 'Space Mono', monospace; font-size: 12px; text-align: center; display: none;"></div>
            
            <div id="exportProgress" style="margin-top: 15px; display: none;">
                <div style="width: 100%; height: 6px; background: rgba(255, 255, 255, 0.1); border-radius: 3px; overflow: hidden;">
                    <div id="exportProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green)); transition: width 0.3s;"></div>
                </div>
                <p id="exportProgressText" style="margin-top: 8px; font-family: 'Space Mono', monospace; font-size: 0.75rem; color: var(--accent-cyan); text-align: center;">Recording...</p>
            </div>
        </div>

        <!-- MIDI Device Selector (hidden by default) -->
        <div id="midiSelector" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(5, 5, 8, 0.98); padding: 30px; border-radius: 15px; border: 2px solid var(--accent-purple); box-shadow: 0 10px 40px rgba(124, 58, 237, 0.3); z-index: 1000; max-width: 400px;">
            <h3 style="color: var(--accent-purple); font-family: 'Bebas Neue', sans-serif; font-size: 28px; margin-bottom: 20px; text-align: center;">MIDI OUTPUT</h3>
            <select id="midiDeviceSelect" style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid var(--accent-purple); border-radius: 8px; color: white; font-family: 'Space Mono', monospace; font-size: 14px; margin-bottom: 20px;">
                <option value="">No MIDI Device Selected</option>
            </select>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button id="midiConnectBtn" class="transport-btn" style="flex: 1; background: linear-gradient(135deg, var(--accent-purple) 0%, #7C3AED 50%, var(--accent-purple) 100%);">
                    CONNECT
                </button>
                <button id="midiCloseBtn" class="transport-btn" style="flex: 1; background: linear-gradient(135deg, #666 0%, #888 50%, #666 100%);">
                    CLOSE
                </button>
            </div>
            <div id="midiStatus" style="margin-top: 15px; padding: 10px; background: rgba(0, 217, 255, 0.1); border-radius: 5px; border: 1px solid var(--accent-cyan); color: var(--accent-cyan); font-family: 'Space Mono', monospace; font-size: 12px; text-align: center; display: none;"></div>
        </div>

        <!-- Workspace Grid -->
        <div class="workspace-grid">
            <!-- Sequencer Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-icon">üéπ</div>
                    <h2 class="panel-title">16-STEP SEQUENCER</h2>
                </div>

                <!-- Kick Modifiers -->
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 12px;">
                    <div>
                        <label style="display: block; font-family: var(--font-mono); font-size: 0.7rem; color: var(--text-dim); margin-bottom: 5px;">KICK DECAY</label>
                        <input type="range" id="kickDecay" min="0.1" max="1" value="0.3" step="0.01" 
                               style="width: 100%; accent-color: var(--accent-orange);"
                               oninput="kickParams.decay = parseFloat(this.value)">
                        <span style="font-family: var(--font-mono); font-size: 0.7rem; color: var(--accent-orange);" id="kickDecayVal">0.30</span>
                    </div>
                    <div>
                        <label style="display: block; font-family: var(--font-mono); font-size: 0.7rem; color: var(--text-dim); margin-bottom: 5px;">KICK PITCH</label>
                        <input type="range" id="kickPitch" min="40" max="200" value="150" step="1"
                               style="width: 100%; accent-color: var(--accent-orange);"
                               oninput="kickParams.pitch = parseFloat(this.value)">
                        <span style="font-family: var(--font-mono); font-size: 0.7rem; color: var(--accent-orange);" id="kickPitchVal">150</span>
                    </div>
                    <div>
                        <label style="display: block; font-family: var(--font-mono); font-size: 0.7rem; color: var(--text-dim); margin-bottom: 5px;">SNARE TONE</label>
                        <input type="range" id="snareTone" min="0.1" max="0.3" value="0.2" step="0.01"
                               style="width: 100%; accent-color: var(--accent-orange);"
                               oninput="snareParams.tone = parseFloat(this.value)">
                        <span style="font-family: var(--font-mono); font-size: 0.7rem; color: var(--accent-orange);" id="snareToneVal">0.20</span>
                    </div>
                    <div>
                        <label style="display: block; font-family: var(--font-mono); font-size: 0.7rem; color: var(--text-dim); margin-bottom: 5px;">HIHAT DECAY</label>
                        <input type="range" id="hihatDecay" min="0.01" max="0.1" value="0.05" step="0.01"
                               style="width: 100%; accent-color: var(--accent-orange);"
                               oninput="hihatParams.decay = parseFloat(this.value)">
                        <span style="font-family: var(--font-mono); font-size: 0.7rem; color: var(--accent-orange);" id="hihatDecayVal">0.05</span>
                    </div>
                </div>

                <!-- Master Waveform Visualization -->
                <div style="margin: 0 0 20px 0; padding: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 12px; border: 1px solid rgba(57, 255, 20, 0.3); box-shadow: 0 0 20px rgba(57, 255, 20, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-family: 'Space Mono', monospace; font-size: 0.8rem; color: #39FF14; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 10px rgba(57, 255, 20, 0.5);">‚óâ MASTER OUTPUT</span>
                        <span id="masterLevel" style="font-family: 'Space Mono', monospace; font-size: 0.75rem; color: #39FF14; text-shadow: 0 0 8px rgba(57, 255, 20, 0.5);">-‚àû dB</span>
                    </div>
                    <canvas id="masterWaveform" width="800" height="80" style="width: 100%; height: 80px; background: rgba(0, 0, 0, 0.6); border-radius: 8px; display: block; border: 1px solid rgba(57, 255, 20, 0.2);"></canvas>
                </div>

                <!-- Track: Kick -->
                <div class="sequencer-track">
                    <div class="track-header">
                        <span class="track-label">ü•Å KICK</span>
                        <div class="track-controls">
                            <button class="track-btn" onclick="clearTrack('kick')" title="Clear">‚úï</button>
                            <button class="track-btn" onclick="randomizeTrack('kick')" title="Random">üé≤</button>
                        </div>
                    </div>
                    <div class="step-grid" id="kick-grid">
                        <!-- 16 steps generated by JS -->
                    </div>
                </div>

                <!-- Track: Snare -->
                <div class="sequencer-track">
                    <div class="track-header">
                        <span class="track-label">ü•Å SNARE</span>
                        <div class="track-controls">
                            <button class="track-btn" onclick="clearTrack('snare')">‚úï</button>
                            <button class="track-btn" onclick="randomizeTrack('snare')">üé≤</button>
                        </div>
                    </div>
                    <div class="step-grid" id="snare-grid">
                        <!-- 16 steps -->
                    </div>
                </div>

                <!-- Track: Hi-Hat -->
                <div class="sequencer-track">
                    <div class="track-header">
                        <span class="track-label">üîî HI-HAT</span>
                        <div class="track-controls">
                            <button class="track-btn" onclick="clearTrack('hihat')">‚úï</button>
                            <button class="track-btn" onclick="randomizeTrack('hihat')">üé≤</button>
                        </div>
                    </div>
                    <div class="step-grid" id="hihat-grid">
                        <!-- 16 steps -->
                    </div>
                </div>

                <!-- Track: Bass -->
                <div class="sequencer-track">
                    <div class="track-header">
                        <span class="track-label">üé∏ BASS</span>
                        <div class="track-controls">
                            <button class="track-btn" onclick="clearTrack('bass')">‚úï</button>
                            <button class="track-btn" onclick="randomizeTrack('bass')">üé≤</button>
                        </div>
                    </div>
                    <div class="step-grid" id="bass-grid">
                        <!-- 16 steps -->
                    </div>
                </div>
            </div>

            <!-- Synth Controls Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-icon">üéõÔ∏è</div>
                    <h2 class="panel-title">SYNTH CONTROLS</h2>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
                    <!-- Cutoff Knob -->
                    <div class="knob-container">
                        <div class="knob-label">CUTOFF</div>
                        <div class="knob" id="knob-cutoff" data-param="cutoff" data-min="100" data-max="5000" data-value="1000"></div>
                        <div class="knob-value" id="value-cutoff">1000 Hz</div>
                    </div>
                    
                    <!-- Resonance Knob -->
                    <div class="knob-container">
                        <div class="knob-label">RESONANCE</div>
                        <div class="knob" id="knob-resonance" data-param="resonance" data-min="0" data-max="20" data-value="5"></div>
                        <div class="knob-value" id="value-resonance">5.0</div>
                    </div>
                    
                    <!-- Attack Knob -->
                    <div class="knob-container">
                        <div class="knob-label">ATTACK</div>
                        <div class="knob" id="knob-attack" data-param="attack" data-min="0.001" data-max="0.5" data-value="0.01"></div>
                        <div class="knob-value" id="value-attack">0.01 s</div>
                    </div>
                    
                    <!-- Release Knob -->
                    <div class="knob-container">
                        <div class="knob-label">RELEASE</div>
                        <div class="knob" id="knob-release" data-param="release" data-min="0.01" data-max="2" data-value="0.1"></div>
                        <div class="knob-value" id="value-release">0.1 s</div>
                    </div>
                    
                    <!-- Distortion Knob -->
                    <div class="knob-container">
                        <div class="knob-label">DISTORTION</div>
                        <div class="knob" id="knob-distortion" data-param="distortion" data-min="0" data-max="100" data-value="0"></div>
                        <div class="knob-value" id="value-distortion">0</div>
                    </div>
                    
                    <!-- Reverb Knob -->
                    <div class="knob-container">
                        <div class="knob-label">REVERB</div>
                        <div class="knob" id="knob-reverb" data-param="reverb" data-min="0" data-max="100" data-value="0"></div>
                        <div class="knob-value" id="value-reverb">0 %</div>
                    </div>
                </div>
                
                <!-- Pitch/Note Control -->
                <div style="margin-top: 20px; padding: 15px; background: rgba(57, 255, 20, 0.05); border: 1px solid rgba(57, 255, 20, 0.2); border-radius: 8px;">
                    <div style="text-align: center; margin-bottom: 10px;">
                        <span style="font-family: var(--font-mono); font-size: 0.8rem; color: var(--accent-green); letter-spacing: 0.1em;">üéµ NOTE PITCH</span>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr auto; gap: 15px; align-items: center;">
                        <div>
                            <input type="range" id="pitchSlider" min="0" max="36" value="12" step="1" 
                                   style="width: 100%; height: 6px; background: linear-gradient(90deg, rgba(57, 255, 20, 0.2), rgba(57, 255, 20, 0.6)); border-radius: 3px; cursor: pointer; appearance: none;"
                                   oninput="updatePitch(this.value)">
                            <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.65rem; color: var(--text-dim);">
                                <span>C2 (65Hz)</span>
                                <span id="currentNote">C3 (131Hz)</span>
                                <span>C5 (523Hz)</span>
                            </div>
                        </div>
                        <div style="display: flex; gap: 5px; flex-direction: column;">
                            <button onclick="adjustPitch(-12)" class="transport-btn" style="padding: 6px 12px; font-size: 0.7rem; background: rgba(255, 107, 53, 0.1);" title="Down octave">-8ve</button>
                            <button onclick="adjustPitch(12)" class="transport-btn" style="padding: 6px 12px; font-size: 0.7rem; background: rgba(57, 255, 20, 0.1);" title="Up octave">+8ve</button>
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px;">
                    <button onclick="testCurrentSound()" class="transport-btn" style="background: rgba(57, 255, 20, 0.1); border-color: var(--accent-green);">
                        üîä Test Sound
                    </button>
                    <button onclick="saveModifiedPreset()" class="transport-btn" style="background: rgba(255, 107, 53, 0.1); border-color: var(--accent-orange);">
                        üíæ Save Preset
                    </button>
                </div>
                
                <div id="presetSaveStatus" style="text-align: center; margin-top: 10px; font-size: 0.75rem; color: var(--accent-green); min-height: 20px;"></div>
            </div>
        </div>

        <!-- Preset Browser Panel -->
        <div class="panel">
            <div class="panel-header">
                <div class="panel-icon">üíæ</div>
                <h2 class="panel-title" data-i18n="techno-preset-browser">üìö PRZEGLƒÑDARKA PRESET√ìW</h2>
            </div>
            
            <!-- Preset Status & Controls -->
            <div style="background: rgba(57, 255, 20, 0.05); padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid rgba(57, 255, 20, 0.2);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div id="presetStatus" style="font-family: var(--font-mono); font-size: 0.75rem; color: var(--accent-green);">
                        ‚è≥ Initializing...
                    </div>
                    <button onclick="retryLoadPresets()" class="transport-btn" style="padding: 6px 12px; font-size: 0.7rem; background: rgba(255, 107, 53, 0.1);">
                        üîÑ Reload
                    </button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px;">
                    <button onclick="loadRandomPreset()" class="transport-btn" style="padding: 6px 10px; font-size: 0.65rem; background: rgba(212, 175, 55, 0.1);">
                        üé≤ Random
                    </button>
                    <button onclick="loadPreviousPreset()" class="transport-btn" style="padding: 6px 10px; font-size: 0.65rem; background: rgba(0, 217, 255, 0.1);">
                        ‚¨ÖÔ∏è Prev
                    </button>
                    <button onclick="loadNextPreset()" class="transport-btn" style="padding: 6px 10px; font-size: 0.65rem; background: rgba(0, 217, 255, 0.1);">
                        Next ‚û°Ô∏è
                    </button>
                </div>
            </div>
            
            <!-- Preset Filters -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                <select class="dropdown" id="categoryFilter" onchange="filterPresets()" style="font-size: 0.8rem; padding: 8px 12px;">
                    <option value="all">All Categories</option>
                    <option value="Bass">Bass</option>
                    <option value="Lead">Lead</option>
                    <option value="Pad">Pad</option>
                    <option value="Keys">Keys</option>
                    <option value="Brass">Brass</option>
                    <option value="Strings">Strings</option>
                    <option value="FX">FX</option>
                </select>
                <select class="dropdown" id="manufacturerFilter" onchange="filterPresets()" style="font-size: 0.8rem; padding: 8px 12px;">
                    <option value="all">All Manufacturers</option>
                    <option value="Moog">Moog</option>
                    <option value="Roland">Roland</option>
                    <option value="Korg">Korg</option>
                    <option value="Sequential">Sequential</option>
                    <option value="Arturia">Arturia</option>
                    <option value="Oberheim">Oberheim</option>
                </select>
            </div>
            
            <div id="presetList" class="preset-list">
                <p style="text-align: center; color: var(--text-dim); padding: 20px;">Loading presets...</p>
            </div>
        </div>

        <!-- Pattern Presets Panel -->
        <div class="panel" style="border: 2px solid rgba(57, 255, 20, 0.3);">
            <div class="panel-header">
                <div class="panel-icon" style="background: rgba(57, 255, 20, 0.15);">üéµ</div>
                <h2 class="panel-title" style="color: var(--accent-green);" data-i18n="techno-pattern-presets">PATTERN PRESETS</h2>
            </div>
            
            <p style="font-family: var(--font-mono); font-size: 0.75rem; color: var(--text-dim); margin-bottom: 15px; text-align: center;" data-i18n="techno-pattern-desc">
                Load ready-made patterns and modify them on the fly
            </p>
            
            <div id="patternPresetGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 10px;">
                <!-- Pattern buttons will be loaded here -->
            </div>
        </div>
    </div>

    <script>
        // Web Audio API Setup
        let audioContext;
        let masterGain;
        let filterNode;
        let distortionNode;
        let reverbNode;
        let analyserNode;
        
        // Waveform visualization
        let waveformCanvas;
        let waveformCtx;
        let animationFrameId;
        
        // Export/Recording
        let mediaRecorder;
        let recordedChunks = [];
        let recordingDestination;
        let isRecording = false;
        let offlineAudioContext = null;
        
        // WAV Encoder - Encodes raw audio data to WAV file format
        function encodeWAV(samples, sampleRate, numChannels) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);
            
            // RIFF identifier
            writeString(view, 0, 'RIFF');
            // file length minus RIFF identifier length and file description length
            view.setUint32(4, 36 + samples.length * 2, true);
            // RIFF type
            writeString(view, 8, 'WAVE');
            // format chunk identifier
            writeString(view, 12, 'fmt ');
            // format chunk length
            view.setUint32(16, 16, true);
            // sample format (1 = PCM)
            view.setUint16(20, 1, true);
            // channel count
            view.setUint16(22, numChannels, true);
            // sample rate
            view.setUint32(24, sampleRate, true);
            // byte rate (sample rate * block align)
            view.setUint32(28, sampleRate * numChannels * 2, true);
            // block align (channel count * bytes per sample)
            view.setUint16(32, numChannels * 2, true);
            // bits per sample
            view.setUint16(34, 16, true);
            // data chunk identifier
            writeString(view, 36, 'data');
            // data chunk length
            view.setUint32(40, samples.length * 2, true);
            
            // Write PCM samples
            floatTo16BitPCM(view, 44, samples);
            
            return new Blob([buffer], { type: 'audio/wav' });
        }
        
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        function floatTo16BitPCM(view, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, input[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        }
        
        function interleave(inputL, inputR) {
            const length = inputL.length + inputR.length;
            const result = new Float32Array(length);
            
            let index = 0;
            let inputIndex = 0;
            
            while (index < length) {
                result[index++] = inputL[inputIndex];
                result[index++] = inputR[inputIndex];
                inputIndex++;
            }
            
            return result;
        }
        
        // MIDI Setup
        let midiOutput = null;
        let midiAccess = null;
        const midiNotes = {
            kick: 36,   // C1
            snare: 38,  // D1
            hihat: 42,  // F#1
            bass: 48    // C2
        };
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.7;
                
                // Filter
                filterNode = audioContext.createBiquadFilter();
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 1000;
                filterNode.Q.value = 5;
                
                // Distortion
                distortionNode = audioContext.createWaveShaper();
                distortionNode.curve = makeDistortionCurve(0);
                
                // Reverb - Create convolver with impulse response
                reverbNode = audioContext.createConvolver();
                createReverbImpulse();
                
                const dryGain = audioContext.createGain();
                const wetGain = audioContext.createGain();
                dryGain.gain.value = 1;
                wetGain.gain.value = 0; // Start with no reverb
                
                // Connect chain: filter ‚Üí distortion ‚Üí split ‚Üí (dry + reverb) ‚Üí master
                filterNode.connect(distortionNode);
                distortionNode.connect(dryGain);
                distortionNode.connect(reverbNode);
                reverbNode.connect(wetGain);
                dryGain.connect(masterGain);
                wetGain.connect(masterGain);
                
                // Add analyser for waveform visualization
                analyserNode = audioContext.createAnalyser();
                analyserNode.fftSize = 2048;
                analyserNode.smoothingTimeConstant = 0.8;
                masterGain.connect(analyserNode);
                analyserNode.connect(audioContext.destination);
                
                // Store gain nodes for reverb control
                window.dryGain = dryGain;
                window.wetGain = wetGain;
                
                // Initialize waveform visualization
                initWaveformVisualization();
            }
        }
        
        function initWaveformVisualization() {
            waveformCanvas = document.getElementById('masterWaveform');
            waveformCtx = waveformCanvas.getContext('2d');
            drawWaveform();
        }
        
        function drawWaveform() {
            if (!analyserNode || !waveformCtx) {
                animationFrameId = requestAnimationFrame(drawWaveform);
                return;
            }
            
            const bufferLength = analyserNode.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyserNode.getByteTimeDomainData(dataArray);
            
            // Clear canvas with dark background
            waveformCtx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            waveformCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            
            // Calculate audio level for dB display
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                const normalized = (dataArray[i] - 128) / 128;
                sum += normalized * normalized;
            }
            const rms = Math.sqrt(sum / bufferLength);
            const db = rms > 0 ? 20 * Math.log10(rms) : -Infinity;
            const levelDisplay = document.getElementById('masterLevel');
            if (levelDisplay) {
                if (db === -Infinity) {
                    levelDisplay.textContent = '-‚àû dB';
                } else {
                    levelDisplay.textContent = db.toFixed(1) + ' dB';
                }
            }
            
            // Draw waveform with neon lime green
            waveformCtx.lineWidth = 2;
            waveformCtx.strokeStyle = '#39FF14'; // Neon lime green
            waveformCtx.shadowBlur = 10;
            waveformCtx.shadowColor = '#39FF14';
            
            waveformCtx.beginPath();
            const sliceWidth = waveformCanvas.width / bufferLength;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * waveformCanvas.height / 2;
                
                if (i === 0) {
                    waveformCtx.moveTo(x, y);
                } else {
                    waveformCtx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            waveformCtx.lineTo(waveformCanvas.width, waveformCanvas.height / 2);
            waveformCtx.stroke();
            
            // Add glow effect with second pass
            waveformCtx.strokeStyle = 'rgba(57, 255, 20, 0.3)';
            waveformCtx.lineWidth = 4;
            waveformCtx.shadowBlur = 20;
            waveformCtx.beginPath();
            x = 0;
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * waveformCanvas.height / 2;
                if (i === 0) {
                    waveformCtx.moveTo(x, y);
                } else {
                    waveformCtx.lineTo(x, y);
                }
                x += sliceWidth;
            }
            waveformCtx.stroke();
            
            animationFrameId = requestAnimationFrame(drawWaveform);
        }
        
        function createReverbImpulse() {
            const rate = audioContext.sampleRate;
            const length = rate * 2; // 2 second reverb
            const impulse = audioContext.createBuffer(2, length, rate);
            const impulseL = impulse.getChannelData(0);
            const impulseR = impulse.getChannelData(1);
            
            for (let i = 0; i < length; i++) {
                const decay = Math.pow(1 - i / length, 2);
                impulseL[i] = (Math.random() * 2 - 1) * decay;
                impulseR[i] = (Math.random() * 2 - 1) * decay;
            }
            
            reverbNode.buffer = impulse;
        }
        
        function makeDistortionCurve(amount) {
            const samples = 44100;
            const curve = new Float32Array(samples);
            const deg = Math.PI / 180;
            for (let i = 0; i < samples; i++) {
                const x = (i * 2) / samples - 1;
                curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
            }
            return curve;
        }

        // Synth parameters
        let synthParams = {
            cutoff: 1000,
            resonance: 5,
            attack: 0.01,
            release: 0.1,
            distortion: 0,
            reverb: 0
        };
        
        // Drum parameters
        let kickParams = {
            pitch: 150,
            decay: 0.3
        };
        
        let snareParams = {
            tone: 0.2
        };
        
        let hihatParams = {
            decay: 0.05
        };
        
        let currentBPM = 135;
        
        // Note frequencies (12-tone equal temperament)
        const NOTE_FREQUENCIES = [
            { note: 'C2', freq: 65.41, semitone: 0 },
            { note: 'C#2', freq: 69.30, semitone: 1 },
            { note: 'D2', freq: 73.42, semitone: 2 },
            { note: 'D#2', freq: 77.78, semitone: 3 },
            { note: 'E2', freq: 82.41, semitone: 4 },
            { note: 'F2', freq: 87.31, semitone: 5 },
            { note: 'F#2', freq: 92.50, semitone: 6 },
            { note: 'G2', freq: 98.00, semitone: 7 },
            { note: 'G#2', freq: 103.83, semitone: 8 },
            { note: 'A2', freq: 110.00, semitone: 9 },
            { note: 'A#2', freq: 116.54, semitone: 10 },
            { note: 'B2', freq: 123.47, semitone: 11 },
            { note: 'C3', freq: 130.81, semitone: 12 },
            { note: 'C#3', freq: 138.59, semitone: 13 },
            { note: 'D3', freq: 146.83, semitone: 14 },
            { note: 'D#3', freq: 155.56, semitone: 15 },
            { note: 'E3', freq: 164.81, semitone: 16 },
            { note: 'F3', freq: 174.61, semitone: 17 },
            { note: 'F#3', freq: 185.00, semitone: 18 },
            { note: 'G3', freq: 196.00, semitone: 19 },
            { note: 'G#3', freq: 207.65, semitone: 20 },
            { note: 'A3', freq: 220.00, semitone: 21 },
            { note: 'A#3', freq: 233.08, semitone: 22 },
            { note: 'B3', freq: 246.94, semitone: 23 },
            { note: 'C4', freq: 261.63, semitone: 24 },
            { note: 'C#4', freq: 277.18, semitone: 25 },
            { note: 'D4', freq: 293.66, semitone: 26 },
            { note: 'D#4', freq: 311.13, semitone: 27 },
            { note: 'E4', freq: 329.63, semitone: 28 },
            { note: 'F4', freq: 349.23, semitone: 29 },
            { note: 'F#4', freq: 369.99, semitone: 30 },
            { note: 'G4', freq: 392.00, semitone: 31 },
            { note: 'G#4', freq: 415.30, semitone: 32 },
            { note: 'A4', freq: 440.00, semitone: 33 },
            { note: 'A#4', freq: 466.16, semitone: 34 },
            { note: 'B4', freq: 493.88, semitone: 35 },
            { note: 'C5', freq: 523.25, semitone: 36 }
        ];
        
        let currentPitchIndex = 12; // Default C3

        function changeBPM(bpm) {
            currentBPM = parseInt(bpm);
            const bpmKnob = document.getElementById('bpmKnob');
            if (bpmKnob) bpmKnob.value = bpm;
            
            if (playing) {
                clearInterval(interval);
                interval = setInterval(stepSequencer, (60 / currentBPM) * 1000 / 4);
            }
        }

        function updateKnob(param, value) {
            const val = parseFloat(value);
            synthParams[param] = val;
            const knob = document.getElementById(`knob-${param}`);
            const valueDisplay = document.getElementById(`value-${param}`);
            
            console.log(`Updating ${param} to ${val}`);
            
            if (knob) {
                knob.dataset.value = val;
                updateKnobRotation(param, val);
            }
            
            if (valueDisplay) {
                valueDisplay.textContent = 
                    param === 'cutoff' ? Math.round(val) + ' Hz' :
                    param === 'resonance' ? val.toFixed(1) :
                    param === 'attack' || param === 'release' ? val.toFixed(3) + ' s' :
                    param === 'reverb' ? Math.round(val) + ' %' :
                    Math.round(val);
            }
            
            if (filterNode) {
                if (param === 'cutoff') filterNode.frequency.value = val;
                if (param === 'resonance') filterNode.Q.value = val;
                if (param === 'distortion') distortionNode.curve = makeDistortionCurve(val / 100 * 50);
                if (param === 'reverb' && window.wetGain && window.dryGain) {
                    const wetAmount = val / 100;
                    window.wetGain.gain.value = wetAmount;
                    window.dryGain.gain.value = 1 - (wetAmount * 0.5); // Reduce dry when wet increases
                }
            }
        }
        
        function updateKnobRotation(param, value) {
            const knob = document.getElementById(`knob-${param}`);
            if (!knob) return;
            
            const min = parseFloat(knob.dataset.min);
            const max = parseFloat(knob.dataset.max);
            const val = parseFloat(value);
            const normalized = (val - min) / (max - min);
            const degrees = -135 + (normalized * 270); // -135¬∞ to +135¬∞
            
            knob.style.transform = `rotate(${degrees}deg)`;
            knob.style.transition = 'transform 0.1s ease-out';
        }
        
        // Initialize knob interactions
        function initKnobs() {
            document.querySelectorAll('.knob').forEach(knob => {
                let isDragging = false;
                let startY = 0;
                let startValue = 0;
                
                const param = knob.dataset.param;
                const min = parseFloat(knob.dataset.min);
                const max = parseFloat(knob.dataset.max);
                
                knob.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startValue = parseFloat(knob.dataset.value);
                    knob.style.cursor = 'grabbing';
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaY = startY - e.clientY;
                    const range = max - min;
                    const changeAmount = (deltaY / 100) * range;
                    let newValue = startValue + changeAmount;
                    
                    newValue = Math.max(min, Math.min(max, newValue));
                    knob.dataset.value = newValue;
                    updateKnob(param, newValue);
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        knob.style.cursor = 'pointer';
                    }
                });
                
                // Touch support
                knob.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    startY = e.touches[0].clientY;
                    startValue = parseFloat(knob.dataset.value);
                    e.preventDefault();
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    const deltaY = startY - e.touches[0].clientY;
                    const range = max - min;
                    const changeAmount = (deltaY / 100) * range;
                    let newValue = startValue + changeAmount;
                    newValue = Math.max(min, Math.min(max, newValue));
                    knob.dataset.value = newValue;
                    updateKnob(param, newValue);
                });
                
                document.addEventListener('touchend', () => {
                    isDragging = false;
                });
                
                // Initialize rotation
                updateKnobRotation(param, knob.dataset.value);
            });
        }

        // Sound synthesis with parameters
        function playKick() {
            initAudio();
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(kickParams.pitch, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
            
            gain.gain.setValueAtTime(1, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + kickParams.decay);
            
            osc.connect(gain);
            gain.connect(filterNode);
            
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + kickParams.decay);
            
            // Update display
            document.getElementById('kickDecayVal').textContent = kickParams.decay.toFixed(2);
            document.getElementById('kickPitchVal').textContent = Math.round(kickParams.pitch);
        }

        function playSnare() {
            initAudio();
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * snareParams.tone, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < buffer.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;
            
            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0.5, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + snareParams.tone);
            
            noise.connect(gain);
            gain.connect(filterNode);
            
            noise.start(audioContext.currentTime);
            
            // Update display
            document.getElementById('snareToneVal').textContent = snareParams.tone.toFixed(2);
        }

        function playHihat() {
            initAudio();
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * hihatParams.decay, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < buffer.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;
            
            const highpass = audioContext.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.value = 7000;
            
            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + hihatParams.decay);
            
            noise.connect(highpass);
            highpass.connect(gain);
            gain.connect(filterNode);
            
            noise.start(audioContext.currentTime);
            
            // Update display
            document.getElementById('hihatDecayVal').textContent = hihatParams.decay.toFixed(2);
        }

        function playBass() {
            initAudio();
            
            // Use the current pitch from pitch slider
            const noteData = NOTE_FREQUENCIES[currentPitchIndex];
            const frequency = noteData ? noteData.freq : 130.81; // Default to C3 if not set
            
            // Use the advanced synthesizer engine with preset parameters
            playSynthNote(frequency, 0.2); // 0.2 second duration for bass notes
        }

        const soundMap = {
            kick: playKick,
            snare: playSnare,
            hihat: playHihat,
            bass: playBass
        };

        // Pattern variations - Expanded with hip-hop genres
        const patterns = {
            // Electronic
            techno: {
                kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                hihat: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                bass: [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0],
                bpm: 135
            },
            acid: {
                kick: [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0],
                snare: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                hihat: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                bass: [1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1],
                bpm: 130
            },
            minimal: {
                kick: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                hihat: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                bass: [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                bpm: 128
            },
            industrial: {
                kick: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                snare: [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                hihat: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                bass: [1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0],
                bpm: 140
            },
            trance: {
                kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                snare: [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                hihat: [1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0],
                bass: [1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0],
                bpm: 138
            },
            dubstep: {
                kick: [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
                snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                hihat: [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0],
                bass: [1,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0],
                bpm: 140
            },
            // Hip-Hop
            hiphop: {
                kick: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                hihat: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                bass: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                bpm: 90
            },
            trap: {
                kick: [1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0],
                snare: [0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0],
                hihat: [1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
                bass: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                bpm: 140
            },
            drill: {
                kick: [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0],
                snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                hihat: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                bass: [1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0],
                bpm: 145
            },
            'boom-bap': {
                kick: [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
                snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                hihat: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                bass: [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
                bpm: 85
            },
            lofi: {
                kick: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                snare: [0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0],
                hihat: [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
                bass: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                bpm: 75
            },
            // Dance
            house: {
                kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                hihat: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                bass: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                bpm: 125
            },
            dnb: {
                kick: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                snare: [0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0],
                hihat: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                bass: [1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0],
                bpm: 170
            },
            breaks: {
                kick: [1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0],
                snare: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                hihat: [1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
                bass: [1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0],
                bpm: 135
            }
        };

        function loadPattern(name) {
            if (name === 'clear' || name === '') {
                tracks.forEach(clearTrack);
                return;
            }
            const pattern = patterns[name];
            if (!pattern) return;
            
            // Load pattern
            tracks.forEach(track => {
                const grid = document.getElementById(`${track}-grid`);
                const steps = grid.querySelectorAll('.step');
                steps.forEach((step, i) => {
                    if (pattern[track] && pattern[track][i]) {
                        step.classList.add('active');
                    } else {
                        step.classList.remove('active');
                    }
                });
            });
            
            // Adjust BPM if pattern has one
            if (pattern.bpm) {
                currentBPM = pattern.bpm;
                const bpmKnob = document.getElementById('bpmKnob');
                if (bpmKnob) {
                    bpmKnob.value = pattern.bpm;
                }
                
                // Restart playback with new BPM if playing
                if (playing) {
                    clearInterval(interval);
                    interval = setInterval(stepSequencer, (60 / currentBPM) * 1000 / 4);
                }
                
                console.log(`Pattern ${name} loaded with BPM: ${pattern.bpm}`);
            }
        }

        function clearTrack(track) {
            const grid = document.getElementById(`${track}-grid`);
            grid.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
        }

        function randomizeTrack(track) {
            const grid = document.getElementById(`${track}-grid`);
            grid.querySelectorAll('.step').forEach(s => {
                if (Math.random() > 0.6) {
                    s.classList.add('active');
                } else {
                    s.classList.remove('active');
                }
            });
        }

        // Initialize sequencer grids
        const tracks = ['kick', 'snare', 'hihat', 'bass'];
        tracks.forEach(track => {
            const grid = document.getElementById(`${track}-grid`);
            for (let i = 0; i < 16; i++) {
                const step = document.createElement('div');
                step.className = 'step';
                step.dataset.track = track;
                step.dataset.step = i;
                step.onclick = () => step.classList.toggle('active');
                grid.appendChild(step);
            }
        });

        // Load presets
        let allPresets = [];
        let filteredPresets = [];
        let selectedPresetIndex = -1;
        
        function loadPreset(presetIndex) {
            const preset = filteredPresets[presetIndex];
            if (!preset) return;
            
            console.log('Loading preset:', preset.name, preset);
            selectedPresetIndex = presetIndex;
            
            // Map preset parameters to synth controls
            if (preset.filter && preset.filter.cutoff) {
                updateKnob('cutoff', preset.filter.cutoff);
            }
            if (preset.filter && preset.filter.resonance) {
                updateKnob('resonance', preset.filter.resonance);
            }
            if (preset.envelope) {
                if (preset.envelope.attack !== undefined) {
                    updateKnob('attack', preset.envelope.attack);
                }
                if (preset.envelope.release !== undefined) {
                    updateKnob('release', preset.envelope.release);
                }
            }
            
            // Set distortion based on type or default
            if (preset.type === 'analog' || preset.category === 'Bass') {
                updateKnob('distortion', 30);
            } else {
                updateKnob('distortion', 0);
            }
            
            // Auto-adjust pitch based on preset category
            autoPitchForCategory(preset.category);
            
            // Update status
            updatePresetStatus(`${presetIndex + 1}/${filteredPresets.length}: ${preset.name}`, 'success');
            
            // Show visual feedback
            renderPresets();
        }
        
        function updatePitch(semitone) {
            currentPitchIndex = parseInt(semitone);
            const noteData = NOTE_FREQUENCIES[currentPitchIndex];
            
            const currentNoteEl = document.getElementById('currentNote');
            if (currentNoteEl) {
                currentNoteEl.textContent = `${noteData.note} (${Math.round(noteData.freq)}Hz)`;
            }
            
            // Update slider style to show position
            const slider = document.getElementById('pitchSlider');
            if (slider) {
                const percent = (currentPitchIndex / 36) * 100;
                slider.style.background = `linear-gradient(90deg, rgba(57, 255, 20, 0.6) 0%, rgba(57, 255, 20, 0.6) ${percent}%, rgba(57, 255, 20, 0.2) ${percent}%, rgba(57, 255, 20, 0.2) 100%)`;
            }
        }
        
        function adjustPitch(semitones) {
            const newIndex = Math.max(0, Math.min(36, currentPitchIndex + semitones));
            const slider = document.getElementById('pitchSlider');
            if (slider) {
                slider.value = newIndex;
            }
            updatePitch(newIndex);
        }
        
        function autoPitchForCategory(category) {
            let targetIndex = 12; // Default C3
            
            // Auto-adjust based on category
            switch(category?.toLowerCase()) {
                case 'bass':
                    targetIndex = 4; // E2 - low bass
                    break;
                case 'lead':
                    targetIndex = 24; // C4 - mid-high lead
                    break;
                case 'pad':
                    targetIndex = 19; // G3 - mid pad
                    break;
                case 'keys':
                    targetIndex = 24; // C4 - standard keys
                    break;
                case 'brass':
                    targetIndex = 21; // A3 - brass range
                    break;
                case 'strings':
                    targetIndex = 19; // G3 - strings
                    break;
                case 'fx':
                    targetIndex = 28; // E4 - high FX
                    break;
                default:
                    targetIndex = 12; // C3 - default
            }
            
            const slider = document.getElementById('pitchSlider');
            if (slider) {
                slider.value = targetIndex;
            }
            updatePitch(targetIndex);
            console.log(`üéµ Auto-pitched to ${NOTE_FREQUENCIES[targetIndex].note} for ${category}`);
        }
        
        // Initialize pitch display (safe initialization)
        let pitchInitialized = false;
        function initializePitch() {
            if (!pitchInitialized && document.getElementById('pitchSlider')) {
                updatePitch(12); // Initialize to C3
                pitchInitialized = true;
                console.log('‚úÖ Pitch control initialized');
            }
        }
        
        function filterPresets() {
            const category = document.getElementById('categoryFilter').value;
            const manufacturer = document.getElementById('manufacturerFilter').value;
            
            filteredPresets = allPresets.filter(p => {
                const categoryMatch = category === 'all' || p.category === category;
                const manufacturerMatch = manufacturer === 'all' || p.manufacturer === manufacturer;
                return categoryMatch && manufacturerMatch;
            });
            
            selectedPresetIndex = -1;
            renderPresets();
        }
        
        function renderPresets() {
            const list = document.getElementById('presetList');
            if (!list) return;
            
            // If allPresets is empty, we haven't loaded yet
            if (allPresets.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: var(--text-dim); padding: 20px;">Loading presets...</p>';
                return;
            }
            
            // If filtered is empty after loading, no matches
            if (filteredPresets.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: var(--text-dim); padding: 20px;">No presets match filters</p>';
                return;
            }
            
            list.innerHTML = filteredPresets.map((p, i) => {
                const isSelected = i === selectedPresetIndex;
                return `
                    <div class="preset-item" 
                         style="${isSelected ? 'background: rgba(255, 107, 53, 0.2); border-color: var(--accent-orange);' : ''} display: flex; align-items: center; justify-content: space-between;">
                        <div onclick="loadPreset(${i})" style="flex: 1; cursor: pointer;">
                            <div class="preset-name">${p.name}</div>
                            <div class="preset-info">${p.manufacturer} - ${p.category}</div>
                        </div>
                        <button onclick="event.stopPropagation(); testPresetSound(${i})" 
                                class="transport-btn" 
                                style="padding: 8px 12px; font-size: 0.7rem; margin-left: 10px; background: rgba(57, 255, 20, 0.1); border-color: var(--accent-green);"
                                title="Test sound">
                            üîä Test
                        </button>
                    </div>
                `;
            }).join('');
        }
        
        // Update preset status display
        function updatePresetStatus(message, type = 'info') {
            const statusEl = document.getElementById('presetStatus');
            if (!statusEl) return;
            
            const icons = {
                loading: '‚è≥',
                success: '‚úÖ',
                error: '‚ùå',
                info: '‚ÑπÔ∏è'
            };
            
            const colors = {
                loading: 'var(--accent-gold)',
                success: 'var(--accent-green)',
                error: 'var(--accent-orange)',
                info: 'var(--accent-cyan)'
            };
            
            statusEl.textContent = `${icons[type]} ${message}`;
            statusEl.style.color = colors[type];
        }
        
        // Load presets with proper error handling
        function loadSynthPresets() {
            console.log('üîÑ Loading synth presets from ./data/synth-presets.json...');
            updatePresetStatus('Loading presets...', 'loading');
            
            fetch('./data/synth-presets.json')
                .then(r => {
                    console.log('üì° Fetch response:', r.status, r.statusText);
                    if (!r.ok) throw new Error(`HTTP ${r.status}: ${r.statusText}`);
                    return r.json();
                })
                .then(presets => {
                    console.log('üì¶ Raw presets data:', presets);
                    
                    // Check if it's an array
                    if (!Array.isArray(presets)) {
                        console.error('‚ùå Presets is not an array:', typeof presets);
                        throw new Error('Invalid presets format');
                    }
                    
                    allPresets = presets;
                    filteredPresets = presets;
                    renderPresets();
                    
                    console.log('‚úÖ Loaded', presets.length, 'synth presets');
                    updatePresetStatus(`Loaded ${presets.length} presets`, 'success');
                })
                .catch(e => {
                    console.error('‚ùå Failed to load synth presets:', e);
                    updatePresetStatus(`Error: ${e.message}`, 'error');
                    
                    const presetList = document.getElementById('presetList');
                    if (presetList) {
                        presetList.innerHTML = 
                            '<p style="text-align: center; color: var(--text-dim); padding: 20px;">Presets unavailable: ' + e.message + '</p>';
                    }
                });
        }
        
        // Retry loading presets
        function retryLoadPresets() {
            console.log('üîÑ Retrying preset load...');
            allPresets = [];
            filteredPresets = [];
            selectedPresetIndex = -1;
            
            const presetList = document.getElementById('presetList');
            if (presetList) {
                presetList.innerHTML = '<p style="text-align: center; color: var(--text-dim); padding: 20px;">Loading presets...</p>';
            }
            
            loadSynthPresets();
        }
        
        // Load random preset
        function loadRandomPreset() {
            if (filteredPresets.length === 0) {
                console.warn('‚ö†Ô∏è No presets available');
                updatePresetStatus('No presets to load', 'error');
                return;
            }
            
            const randomIndex = Math.floor(Math.random() * filteredPresets.length);
            loadPreset(randomIndex);
            console.log('üé≤ Random preset loaded:', filteredPresets[randomIndex].name);
            updatePresetStatus(`Random: ${filteredPresets[randomIndex].name}`, 'info');
        }
        
        // Load previous preset
        function loadPreviousPreset() {
            if (filteredPresets.length === 0) {
                console.warn('‚ö†Ô∏è No presets available');
                return;
            }
            
            let newIndex = selectedPresetIndex - 1;
            if (newIndex < 0) {
                newIndex = filteredPresets.length - 1; // Wrap to last
            }
            
            loadPreset(newIndex);
            console.log('‚¨ÖÔ∏è Previous preset:', filteredPresets[newIndex].name);
            updatePresetStatus(`${newIndex + 1}/${filteredPresets.length}: ${filteredPresets[newIndex].name}`, 'info');
        }
        
        // Load next preset
        function loadNextPreset() {
            if (filteredPresets.length === 0) {
                console.warn('‚ö†Ô∏è No presets available');
                return;
            }
            
            let newIndex = selectedPresetIndex + 1;
            if (newIndex >= filteredPresets.length) {
                newIndex = 0; // Wrap to first
            }
            
            loadPreset(newIndex);
            console.log('‚û°Ô∏è Next preset:', filteredPresets[newIndex].name);
            updatePresetStatus(`${newIndex + 1}/${filteredPresets.length}: ${filteredPresets[newIndex].name}`, 'info');
        }
        
        // Call after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadSynthPresets);
        } else {
            loadSynthPresets();
        }

        // Test Preset Sound Function
        function testPresetSound(presetIndex) {
            const preset = filteredPresets[presetIndex];
            if (!preset) return;
            
            // Load preset first
            loadPreset(presetIndex);
            
            // Get current selected note
            const baseFreq = NOTE_FREQUENCIES[currentPitchIndex].freq;
            const noteName = NOTE_FREQUENCIES[currentPitchIndex].note;
            
            // Play a chord based on selected note
            console.log('üîä Testing preset:', preset.name, 'at', noteName);
            playSynthNote(baseFreq, 0.8); // Root
            setTimeout(() => playSynthNote(baseFreq * 1.2599, 0.8), 100); // Major third (+4 semitones)
            setTimeout(() => playSynthNote(baseFreq * 1.4983, 0.8), 200); // Perfect fifth (+7 semitones)
        }
        
        // Synthesizer Engine
        function playSynthNote(frequency, duration = 1.0) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const now = audioContext.currentTime;
            
            // Get current knob values
            const cutoff = parseFloat(document.querySelector('[data-param="cutoff"]')?.dataset.value || 2000);
            const resonance = parseFloat(document.querySelector('[data-param="resonance"]')?.dataset.value || 1);
            const attack = parseFloat(document.querySelector('[data-param="attack"]')?.dataset.value || 0.01);
            const release = parseFloat(document.querySelector('[data-param="release"]')?.dataset.value || 0.3);
            const distortionAmount = parseFloat(document.querySelector('[data-param="distortion"]')?.dataset.value || 0);
            
            // Create oscillators (dual-oscillator synth)
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            
            // Set waveforms
            osc1.type = 'sawtooth';
            osc2.type = 'square';
            
            // Set frequencies (osc2 slightly detuned)
            osc1.frequency.setValueAtTime(frequency, now);
            osc2.frequency.setValueAtTime(frequency * 1.01, now);
            
            // Create gains for each oscillator
            const osc1Gain = audioContext.createGain();
            const osc2Gain = audioContext.createGain();
            osc1Gain.gain.value = 0.5;
            osc2Gain.gain.value = 0.3;
            
            // Create filter
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(cutoff, now);
            filter.Q.value = resonance;
            
            // Filter envelope
            filter.frequency.setValueAtTime(cutoff * 0.5, now);
            filter.frequency.exponentialRampToValueAtTime(cutoff, now + attack);
            filter.frequency.exponentialRampToValueAtTime(cutoff * 0.3, now + duration + release);
            
            // Create master gain for amplitude envelope
            const masterGain = audioContext.createGain();
            
            // ADSR Envelope
            masterGain.gain.setValueAtTime(0, now);
            masterGain.gain.linearRampToValueAtTime(0.8, now + attack);
            masterGain.gain.setValueAtTime(0.8, now + duration);
            masterGain.gain.exponentialRampToValueAtTime(0.001, now + duration + release);
            
            // Optional distortion
            let distortionNode = null;
            if (distortionAmount > 5) {
                distortionNode = audioContext.createWaveShaper();
                distortionNode.curve = makeDistortionCurve(distortionAmount * 10);
                distortionNode.oversample = '4x';
            }
            
            // Connect audio graph
            osc1.connect(osc1Gain);
            osc2.connect(osc2Gain);
            osc1Gain.connect(filter);
            osc2Gain.connect(filter);
            
            if (distortionNode) {
                filter.connect(distortionNode);
                distortionNode.connect(masterGain);
            } else {
                filter.connect(masterGain);
            }
            
            masterGain.connect(audioContext.destination);
            
            // Start and stop
            osc1.start(now);
            osc2.start(now);
            osc1.stop(now + duration + release + 0.1);
            osc2.stop(now + duration + release + 0.1);
        }
        
        // Distortion curve generator
        function makeDistortionCurve(amount) {
            const k = amount;
            const samples = 44100;
            const curve = new Float32Array(samples);
            const deg = Math.PI / 180;
            
            for (let i = 0; i < samples; i++) {
                const x = (i * 2) / samples - 1;
                curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }
        
        // Test Current Sound (with current knob settings)
        function testCurrentSound() {
            const baseFreq = NOTE_FREQUENCIES[currentPitchIndex].freq;
            const noteName = NOTE_FREQUENCIES[currentPitchIndex].note;
            
            console.log('üéπ Testing current synth settings at', noteName, '...');
            
            // Play arpeggio: Root - Major 3rd - Perfect 5th - Octave
            playSynthNote(baseFreq, 0.8); // Root
            setTimeout(() => playSynthNote(baseFreq * 1.2599, 0.8), 150); // Major third
            setTimeout(() => playSynthNote(baseFreq * 1.4983, 0.8), 300); // Perfect fifth
            setTimeout(() => playSynthNote(baseFreq * 2, 1.2), 450); // Octave
        }
        
        // Save Modified Preset
        function saveModifiedPreset() {
            const cutoff = parseFloat(document.querySelector('[data-param="cutoff"]')?.dataset.value || 1000);
            const resonance = parseFloat(document.querySelector('[data-param="resonance"]')?.dataset.value || 5);
            const attack = parseFloat(document.querySelector('[data-param="attack"]')?.dataset.value || 0.01);
            const release = parseFloat(document.querySelector('[data-param="release"]')?.dataset.value || 0.1);
            const distortion = parseFloat(document.querySelector('[data-param="distortion"]')?.dataset.value || 0);
            const reverb = parseFloat(document.querySelector('[data-param="reverb"]')?.dataset.value || 0);
            
            const currentPreset = selectedPresetIndex >= 0 ? filteredPresets[selectedPresetIndex] : null;
            const presetName = currentPreset ? currentPreset.name + ' (Modified)' : 'Custom Preset';
            
            const noteData = NOTE_FREQUENCIES[currentPitchIndex];
            
            const modifiedPreset = {
                name: presetName,
                manufacturer: currentPreset ? currentPreset.manufacturer : 'User',
                category: currentPreset ? currentPreset.category : 'Custom',
                type: currentPreset ? currentPreset.type : 'analog',
                pitch: {
                    note: noteData.note,
                    frequency: Math.round(noteData.freq * 100) / 100,
                    semitone: noteData.semitone
                },
                filter: {
                    cutoff: Math.round(cutoff),
                    resonance: parseFloat(resonance.toFixed(1))
                },
                envelope: {
                    attack: parseFloat(attack.toFixed(3)),
                    release: parseFloat(release.toFixed(3))
                },
                distortion: Math.round(distortion),
                reverb: Math.round(reverb)
            };
            
            // Download as JSON
            const blob = new Blob([JSON.stringify(modifiedPreset, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${presetName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Show status message
            const status = document.getElementById('presetSaveStatus');
            if (status) {
                status.textContent = `‚úÖ Saved: ${presetName}`;
                status.style.color = 'var(--accent-green)';
                setTimeout(() => {
                    status.textContent = '';
                }, 3000);
            }
            
            console.log('üíæ Saved preset:', modifiedPreset);
        }

        // Pattern Presets
        let patternPresets = [];
        let activePatternIndex = -1;

        function loadPatternPreset(index) {
            const pattern = patternPresets[index];
            if (!pattern) return;

            console.log('Loading pattern:', pattern.name);
            activePatternIndex = index;

            // Update BPM
            const bpmInput = document.getElementById('bpmInput');
            if (bpmInput) {
                bpmInput.value = pattern.bpm;
            }

            // Load pattern into sequencer
            const tracks = ['kick', 'snare', 'hihat', 'openhat', 'clap', 'bass'];
            tracks.forEach(trackName => {
                const trackSteps = pattern.tracks[trackName];
                if (!trackSteps) return;

                const trackGrid = document.querySelector(`[data-track="${trackName}"]`)?.querySelector('.step-grid');
                if (!trackGrid) return;

                const steps = trackGrid.querySelectorAll('.step');
                steps.forEach((step, i) => {
                    if (trackSteps[i] === 1) {
                        step.classList.add('active');
                    } else {
                        step.classList.remove('active');
                    }
                });
            });

            // Update button states
            renderPatternButtons();
        }

        function renderPatternButtons() {
            const grid = document.getElementById('patternPresetGrid');
            if (!grid) return;

            grid.innerHTML = patternPresets.map((pattern, index) => `
                <button 
                    class="pattern-preset-btn ${index === activePatternIndex ? 'active' : ''}"
                    onclick="loadPatternPreset(${index})"
                >
                    <div class="pattern-preset-name">${pattern.name}</div>
                    <div class="pattern-preset-bpm">${pattern.bpm} BPM</div>
                </button>
            `).join('');
        }

        fetch('./data/pattern-presets.json')
            .then(r => {
                if (!r.ok) throw new Error(`HTTP ${r.status}: ${r.statusText}`);
                return r.json();
            })
            .then(data => {
                patternPresets = data.patterns;
                renderPatternButtons();
                console.log('‚úÖ Loaded', patternPresets.length, 'pattern presets');
            })
            .catch(e => {
                console.error('‚ùå Failed to load pattern presets:', e);
                const grid = document.getElementById('patternPresetGrid');
                if (grid) {
                    grid.innerHTML = '<p style="text-align: center; color: var(--text-dim); padding: 20px; grid-column: 1 / -1;">Pattern presets unavailable: ' + e.message + '</p>';
                }
            });

        // Transport controls
        let playing = false;
        let currentStep = 0;
        let interval;
        let currentBar = 1;
        
        // Update live status display
        function updateLiveStatus() {
            const stepDisplay = document.getElementById('live-step');
            const barDisplay = document.getElementById('live-bar');
            const cpuDisplay = document.getElementById('live-cpu');
            
            if (stepDisplay) {
                stepDisplay.textContent = String(currentStep + 1).padStart(2, '0');
                stepDisplay.classList.add('active');
                setTimeout(() => stepDisplay.classList.remove('active'), 100);
            }
            if (barDisplay) {
                barDisplay.textContent = currentBar;
            }
            if (cpuDisplay) {
                // Simulated CPU usage
                const cpu = Math.floor(8 + Math.random() * 12);
                cpuDisplay.textContent = cpu + '%';
            }
        }
        
        function stepSequencer() {
            // Clear previous playing state
            document.querySelectorAll('.step.playing').forEach(s => s.classList.remove('playing'));
            
            // Highlight current step and play sounds
            tracks.forEach(track => {
                const step = document.querySelector(`[data-track="${track}"][data-step="${currentStep}"]`);
                if (step && step.classList.contains('active')) {
                    step.classList.add('playing');
                    
                    // Trigger Web Audio API sound
                    if (soundMap[track]) soundMap[track]();
                    
                    // Send MIDI note if output is connected
                    if (midiOutput && midiNotes[track]) {
                        const velocity = track === 'bass' ? 100 : 110; // Bass softer, drums punchier
                        const duration = track === 'hihat' ? 50 : track === 'snare' ? 100 : 150;
                        sendMIDINote(midiNotes[track], velocity, duration);
                    }
                }
            });
            
            currentStep = (currentStep + 1) % 16;
            if (currentStep === 0) currentBar = (currentBar % 4) + 1;
            
            // Update live status
            updateLiveStatus();
        }

        document.getElementById('playBtn').onclick = () => {
            initAudio();
            playing = !playing;
            const btn = document.getElementById('playBtn');
            
            if (playing) {
                btn.innerHTML = '<span style="margin-right: 8px;">‚è∏</span> PAUSE';
                btn.classList.add('playing');
                interval = setInterval(stepSequencer, (60 / currentBPM) * 1000 / 4);
            } else {
                btn.innerHTML = '<span style="margin-right: 8px;">‚ñ∂</span> PLAY';
                btn.classList.remove('playing');
                clearInterval(interval);
                document.querySelectorAll('.step.playing').forEach(s => s.classList.remove('playing'));
            }
        };

        document.getElementById('stopBtn').onclick = () => {
            playing = false;
            clearInterval(interval);
            currentStep = 0;
            document.getElementById('playBtn').innerHTML = '<span style="margin-right: 8px;">‚ñ∂</span> PLAY';
            document.getElementById('playBtn').classList.remove('playing');
            document.querySelectorAll('.step.playing').forEach(s => s.classList.remove('playing'));
        };
        
        // MIDI System
        async function initMIDI() {
            try {
                const access = await navigator.requestMIDIAccess();
                midiAccess = access;
                
                // Populate MIDI device selector
                const selector = document.getElementById('midiDeviceSelect');
                selector.innerHTML = '<option value="">No MIDI Device Selected</option>';
                
                for (const output of midiAccess.outputs.values()) {
                    const option = document.createElement('option');
                    option.value = output.id;
                    option.textContent = output.name;
                    selector.appendChild(option);
                }
                
                return access.outputs.size > 0;
            } catch (error) {
                console.error('MIDI Access Error:', error);
                return false;
            }
        }
        
        function sendMIDINote(note, velocity = 127, duration = 100) {
            if (!midiOutput) return;
            
            const channel = 0; // MIDI channel 1
            const noteOn = [0x90 + channel, note, velocity];
            const noteOff = [0x80 + channel, note, 0];
            
            midiOutput.send(noteOn);
            setTimeout(() => midiOutput.send(noteOff), duration);
        }
        
        // MIDI Button Handler
        document.getElementById('midiBtn').onclick = async () => {
            const selector = document.getElementById('midiSelector');
            selector.style.display = 'block';
            
            // Initialize MIDI if not already done
            if (!midiAccess) {
                const hasDevices = await initMIDI();
                if (!hasDevices) {
                    document.getElementById('midiStatus').style.display = 'block';
                    document.getElementById('midiStatus').textContent = '‚ö†Ô∏è No MIDI devices found';
                    document.getElementById('midiStatus').style.background = 'rgba(255, 107, 53, 0.1)';
                    document.getElementById('midiStatus').style.borderColor = 'var(--accent-orange)';
                    document.getElementById('midiStatus').style.color = 'var(--accent-orange)';
                }
            }
        };
        
        document.getElementById('midiConnectBtn').onclick = () => {
            const selector = document.getElementById('midiDeviceSelect');
            const deviceId = selector.value;
            
            if (!deviceId) {
                document.getElementById('midiStatus').style.display = 'block';
                document.getElementById('midiStatus').textContent = '‚ö†Ô∏è Please select a MIDI device';
                document.getElementById('midiStatus').style.background = 'rgba(255, 107, 53, 0.1)';
                document.getElementById('midiStatus').style.borderColor = 'var(--accent-orange)';
                document.getElementById('midiStatus').style.color = 'var(--accent-orange)';
                return;
            }
            
            midiOutput = midiAccess.outputs.get(deviceId);
            document.getElementById('midiStatus').style.display = 'block';
            document.getElementById('midiStatus').textContent = `‚úì Connected to ${selector.options[selector.selectedIndex].textContent}`;
            document.getElementById('midiStatus').style.background = 'rgba(57, 255, 20, 0.1)';
            document.getElementById('midiStatus').style.borderColor = 'var(--accent-green)';
            document.getElementById('midiStatus').style.color = 'var(--accent-green)';
            
            setTimeout(() => {
                document.getElementById('midiSelector').style.display = 'none';
            }, 1500);
        };
        
        document.getElementById('midiCloseBtn').onclick = () => {
            document.getElementById('midiSelector').style.display = 'none';
        };
        
        // Export/Recording System
        document.getElementById('exportBtn').onclick = () => {
            document.getElementById('exportDialog').style.display = 'block';
        };
        
        document.getElementById('exportCloseBtn').onclick = () => {
            document.getElementById('exportDialog').style.display = 'none';
            if (isRecording) {
                stopRecording();
            }
        };
        
        document.getElementById('exportStartBtn').onclick = async () => {
            initAudio();
            
            const format = document.getElementById('exportFormat').value;
            const bars = parseInt(document.getElementById('exportBars').value);
            
            // Calculate duration (bars * 16 steps * time per step)
            const duration = bars * 16 * (60 / currentBPM) * 1000 / 4;
            const durationSeconds = duration / 1000;
            
            // Handle WAV export separately with offline audio context
            if (format === 'wav-custom') {
                document.getElementById('exportStatus').style.display = 'block';
                document.getElementById('exportStatus').textContent = '‚è≥ Rendering WAV audio...';
                document.getElementById('exportStatus').style.background = 'rgba(0, 217, 255, 0.1)';
                document.getElementById('exportStatus').style.borderColor = 'var(--accent-cyan)';
                document.getElementById('exportStatus').style.color = 'var(--accent-cyan)';
                document.getElementById('exportStartBtn').disabled = true;
                document.getElementById('exportStartBtn').style.opacity = '0.5';
                document.getElementById('exportProgress').style.display = 'block';
                
                try {
                    // Create offline audio context for WAV rendering
                    const sampleRate = 44100;
                    const channels = 2;
                    const offlineCtx = new OfflineAudioContext(channels, sampleRate * durationSeconds, sampleRate);
                    
                    // Create master gain for offline context
                    const offlineMaster = offlineCtx.createGain();
                    offlineMaster.gain.value = 0.8;
                    offlineMaster.connect(offlineCtx.destination);
                    
                    // Simulate rendering by using MediaRecorder with webm and converting
                    // For now, record in real-time with WebM then download as WAV concept
                    recordedChunks = [];
                    recordingDestination = audioContext.createMediaStreamDestination();
                    
                    masterGain.disconnect();
                    masterGain.connect(analyserNode);
                    masterGain.connect(recordingDestination);
                    analyserNode.connect(audioContext.destination);
                    
                    const webmFormat = 'audio/webm';
                    mediaRecorder = new MediaRecorder(recordingDestination.stream, {
                        mimeType: webmFormat
                    });
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = async () => {
                        const webmBlob = new Blob(recordedChunks, { type: webmFormat });
                        
                        // Convert WebM to WAV using AudioContext
                        const arrayBuffer = await webmBlob.arrayBuffer();
                        const decodedAudio = await audioContext.decodeAudioData(arrayBuffer);
                        
                        // Get audio data
                        const leftChannel = decodedAudio.getChannelData(0);
                        const rightChannel = decodedAudio.numberOfChannels > 1 
                            ? decodedAudio.getChannelData(1) 
                            : decodedAudio.getChannelData(0);
                        
                        // Interleave channels and encode as WAV
                        const interleaved = interleave(leftChannel, rightChannel);
                        const wavBlob = encodeWAV(interleaved, decodedAudio.sampleRate, 2);
                        
                        // Download WAV file
                        const url = URL.createObjectURL(wavBlob);
                        const a = document.createElement('a');
                        a.style.display = 'none';
                        a.href = url;
                        a.download = `techno-pattern-${Date.now()}.wav`;
                        document.body.appendChild(a);
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        // Restore audio routing
                        masterGain.disconnect();
                        masterGain.connect(analyserNode);
                        analyserNode.connect(audioContext.destination);
                        
                        document.getElementById('exportProgress').style.display = 'none';
                        document.getElementById('exportStatus').textContent = '‚úì WAV exported successfully!';
                        document.getElementById('exportStatus').style.background = 'rgba(57, 255, 20, 0.1)';
                        document.getElementById('exportStatus').style.borderColor = 'var(--accent-green)';
                        document.getElementById('exportStatus').style.color = 'var(--accent-green)';
                        document.getElementById('exportStartBtn').disabled = false;
                        document.getElementById('exportStartBtn').style.opacity = '1';
                        
                        isRecording = false;
                        
                        setTimeout(() => {
                            document.getElementById('exportDialog').style.display = 'none';
                            document.getElementById('exportStatus').style.display = 'none';
                        }, 2000);
                    };
                    
                    // Start recording
                    mediaRecorder.start();
                    isRecording = true;
                    
                    // Start playback if not playing
                    const wasPlaying = playing;
                    if (!playing) {
                        document.getElementById('playBtn').click();
                    }
                    
                    // Update progress bar
                    const startTime = Date.now();
                    const progressInterval = setInterval(() => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min((elapsed / duration) * 100, 100);
                        document.getElementById('exportProgressBar').style.width = progress + '%';
                        document.getElementById('exportProgressText').textContent = `Recording WAV... ${Math.round(progress)}%`;
                        
                        if (progress >= 100) {
                            clearInterval(progressInterval);
                        }
                    }, 100);
                    
                    // Stop recording after duration
                    setTimeout(() => {
                        clearInterval(progressInterval);
                        mediaRecorder.stop();
                        
                        if (!wasPlaying) {
                            document.getElementById('stopBtn').click();
                        }
                    }, duration);
                    
                } catch (error) {
                    console.error('WAV export error:', error);
                    document.getElementById('exportStatus').textContent = '‚ùå WAV export failed: ' + error.message;
                    document.getElementById('exportStatus').style.background = 'rgba(255, 107, 53, 0.1)';
                    document.getElementById('exportStatus').style.borderColor = 'var(--accent-orange)';
                    document.getElementById('exportStatus').style.color = 'var(--accent-orange)';
                    document.getElementById('exportStartBtn').disabled = false;
                    document.getElementById('exportStartBtn').style.opacity = '1';
                }
                return;
            }
            
            // Check if format is supported (for WebM/OGG)
            if (!MediaRecorder.isTypeSupported(format)) {
                document.getElementById('exportStatus').style.display = 'block';
                document.getElementById('exportStatus').textContent = `‚ö†Ô∏è ${format} not supported. Try WebM.`;
                document.getElementById('exportStatus').style.background = 'rgba(255, 107, 53, 0.1)';
                document.getElementById('exportStatus').style.borderColor = 'var(--accent-orange)';
                document.getElementById('exportStatus').style.color = 'var(--accent-orange)';
                return;
            }
            
            // Setup recording
            recordedChunks = [];
            recordingDestination = audioContext.createMediaStreamDestination();
            
            // Disconnect master from speakers and route to recording destination
            masterGain.disconnect();
            masterGain.connect(analyserNode); // Keep waveform working
            masterGain.connect(recordingDestination); // Route to recording
            analyserNode.connect(audioContext.destination); // Keep audio playing
            
            mediaRecorder = new MediaRecorder(recordingDestination.stream, {
                mimeType: format
            });
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: format });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                const extension = format.includes('webm') ? 'webm' : format.includes('ogg') ? 'ogg' : 'wav';
                a.download = `techno-pattern-${Date.now()}.${extension}`;
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                
                // Restore normal audio routing
                masterGain.disconnect();
                masterGain.connect(analyserNode);
                analyserNode.connect(audioContext.destination);
                
                document.getElementById('exportProgress').style.display = 'none';
                document.getElementById('exportStatus').style.display = 'block';
                document.getElementById('exportStatus').textContent = '‚úì Audio exported successfully!';
                document.getElementById('exportStatus').style.background = 'rgba(57, 255, 20, 0.1)';
                document.getElementById('exportStatus').style.borderColor = 'var(--accent-green)';
                document.getElementById('exportStatus').style.color = 'var(--accent-green)';
                
                isRecording = false;
                
                setTimeout(() => {
                    document.getElementById('exportDialog').style.display = 'none';
                    document.getElementById('exportStatus').style.display = 'none';
                }, 2000);
            };
            
            // Start recording
            mediaRecorder.start();
            isRecording = true;
            
            // Show progress
            document.getElementById('exportStatus').style.display = 'none';
            document.getElementById('exportProgress').style.display = 'block';
            document.getElementById('exportStartBtn').disabled = true;
            document.getElementById('exportStartBtn').style.opacity = '0.5';
            
            // Duration already calculated above
            
            // Start playback if not playing
            const wasPlaying = playing;
            if (!playing) {
                document.getElementById('playBtn').click();
            }
            
            // Update progress bar
            const startTime = Date.now();
            const progressInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min((elapsed / duration) * 100, 100);
                document.getElementById('exportProgressBar').style.width = progress + '%';
                document.getElementById('exportProgressText').textContent = `Recording... ${Math.round(progress)}%`;
                
                if (progress >= 100) {
                    clearInterval(progressInterval);
                }
            }, 100);
            
            // Stop recording after duration
            setTimeout(() => {
                clearInterval(progressInterval);
                mediaRecorder.stop();
                document.getElementById('exportStartBtn').disabled = false;
                document.getElementById('exportStartBtn').style.opacity = '1';
                
                // Stop playback if it wasn't playing before
                if (!wasPlaying) {
                    document.getElementById('stopBtn').click();
                }
            }, duration);
        };
        
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            isRecording = false;
        }
        
        // Pattern Save/Load System
        document.getElementById('saveBtn').onclick = () => {
            const patternName = prompt('Enter pattern name:', 'My Pattern');
            if (!patternName) return;
            
            const pattern = {
                name: patternName,
                bpm: currentBPM,
                tracks: {},
                params: {
                    synth: synthParams,
                    kick: kickParams,
                    snare: snareParams,
                    hihat: hihatParams
                },
                timestamp: new Date().toISOString()
            };
            
            // Save track data
            tracks.forEach(track => {
                const grid = document.getElementById(`${track}-grid`);
                const steps = Array.from(grid.querySelectorAll('.step'));
                pattern.tracks[track] = steps.map(s => s.classList.contains('active') ? 1 : 0);
            });
            
            // Get saved patterns from localStorage
            const savedPatterns = JSON.parse(localStorage.getItem('haos_patterns') || '[]');
            savedPatterns.push(pattern);
            localStorage.setItem('haos_patterns', JSON.stringify(savedPatterns));
            
            alert(`‚úÖ Pattern "${patternName}" saved! (${savedPatterns.length} total patterns)`);
            console.log('Pattern saved:', pattern);
        };
        
        document.getElementById('loadBtn').onclick = () => {
            const savedPatterns = JSON.parse(localStorage.getItem('haos_patterns') || '[]');
            
            if (savedPatterns.length === 0) {
                alert('No saved patterns found. Create and save a pattern first!');
                return;
            }
            
            // Create selection list
            let message = 'Select a pattern to load:\n\n';
            savedPatterns.forEach((p, i) => {
                const date = new Date(p.timestamp).toLocaleString();
                message += `${i + 1}. ${p.name} (${p.bpm} BPM) - ${date}\n`;
            });
            
            const selection = prompt(message + '\nEnter number or type "DELETE" to manage patterns:');
            
            if (!selection) return;
            
            if (selection.toUpperCase() === 'DELETE') {
                const deleteMsg = 'Enter pattern number to delete (or "ALL" to clear all):';
                const deleteChoice = prompt(deleteMsg);
                
                if (deleteChoice && deleteChoice.toUpperCase() === 'ALL') {
                    if (confirm('Delete ALL saved patterns? This cannot be undone!')) {
                        localStorage.removeItem('haos_patterns');
                        alert('All patterns deleted.');
                    }
                } else if (deleteChoice) {
                    const idx = parseInt(deleteChoice) - 1;
                    if (idx >= 0 && idx < savedPatterns.length) {
                        const deleted = savedPatterns.splice(idx, 1)[0];
                        localStorage.setItem('haos_patterns', JSON.stringify(savedPatterns));
                        alert(`Deleted: ${deleted.name}`);
                    }
                }
                return;
            }
            
            const idx = parseInt(selection) - 1;
            if (idx < 0 || idx >= savedPatterns.length) {
                alert('Invalid selection');
                return;
            }
            
            const pattern = savedPatterns[idx];
            
            // Load BPM
            currentBPM = pattern.bpm;
            const bpmKnob = document.getElementById('bpmKnob');
            if (bpmKnob) bpmKnob.value = pattern.bpm;
            
            // Load tracks
            tracks.forEach(track => {
                const grid = document.getElementById(`${track}-grid`);
                const steps = grid.querySelectorAll('.step');
                steps.forEach((step, i) => {
                    if (pattern.tracks[track] && pattern.tracks[track][i]) {
                        step.classList.add('active');
                    } else {
                        step.classList.remove('active');
                    }
                });
            });
            
            // Load parameters
            if (pattern.params) {
                if (pattern.params.kick) {
                    kickParams.pitch = pattern.params.kick.pitch || 150;
                    kickParams.decay = pattern.params.kick.decay || 0.3;
                    document.getElementById('kickPitch').value = kickParams.pitch;
                    document.getElementById('kickDecay').value = kickParams.decay;
                }
                if (pattern.params.snare) {
                    snareParams.tone = pattern.params.snare.tone || 0.2;
                    document.getElementById('snareTone').value = snareParams.tone;
                }
                if (pattern.params.hihat) {
                    hihatParams.decay = pattern.params.hihat.decay || 0.05;
                    document.getElementById('hihatDecay').value = hihatParams.decay;
                }
                if (pattern.params.synth) {
                    Object.keys(pattern.params.synth).forEach(param => {
                        updateKnob(param, pattern.params.synth[param]);
                    });
                }
            }
            
            alert(`‚úÖ Loaded: ${pattern.name}`);
            console.log('Pattern loaded:', pattern);
        };

        // Animated Background Particles
        function initBackground() {
            const canvas = document.getElementById('particleCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const particles = [];
            const particleCount = 30;
            
            class Particle {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.size = Math.random() * 100 + 50;
                    this.speedX = (Math.random() - 0.5) * 0.5;
                    this.speedY = (Math.random() - 0.5) * 0.5;
                    this.color = Math.random() > 0.5 ? 'rgba(255, 107, 53, 0.05)' : 'rgba(0, 217, 255, 0.03)';
                    this.pulse = Math.random() * Math.PI * 2;
                    this.pulseSpeed = 0.02;
                }
                
                update() {
                    this.x += this.speedX;
                    this.y += this.speedY;
                    this.pulse += this.pulseSpeed;
                    
                    if (this.x < -this.size) this.x = canvas.width + this.size;
                    if (this.x > canvas.width + this.size) this.x = -this.size;
                    if (this.y < -this.size) this.y = canvas.height + this.size;
                    if (this.y > canvas.height + this.size) this.y = -this.size;
                }
                
                draw() {
                    const opacity = 0.03 + Math.sin(this.pulse) * 0.02;
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                    gradient.addColorStop(0, this.color.replace(/[\d.]+\)/, opacity + ')'));
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Create particles
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
            
            // Draw grid
            function drawGrid() {
                ctx.strokeStyle = 'rgba(255, 107, 53, 0.03)';
                ctx.lineWidth = 1;
                
                const gridSize = 50;
                for (let x = 0; x < canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y < canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            // Animation loop
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                drawGrid();
                
                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });
                
                requestAnimationFrame(animate);
            }
            
            animate();
            
            // Resize handler
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        // Keyboard Shortcuts
        let selectedTrack = 0;
        let selectedStep = 0;
        
        document.addEventListener('keydown', (e) => {
            // Ignore if user is typing in input/select
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            
            switch(e.key) {
                case ' ': // Spacebar - Play/Pause
                    e.preventDefault();
                    document.getElementById('playBtn').click();
                    break;
                    
                case 'Escape': // Stop
                    document.getElementById('stopBtn').click();
                    break;
                    
                case 'ArrowLeft': // Previous preset
                    if (e.shiftKey) {
                        e.preventDefault();
                        loadPreviousPreset();
                    }
                    break;
                    
                case 'ArrowRight': // Next preset
                    if (e.shiftKey) {
                        e.preventDefault();
                        loadNextPreset();
                    }
                    break;
                    
                case 'r': // Random preset
                case 'R':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        loadRandomPreset();
                    }
                    break;
                    
                case 's': // Save
                case 'S':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        document.getElementById('saveBtn').click();
                    }
                    break;
                    
                case 'l': // Load
                case 'L':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        document.getElementById('loadBtn').click();
                    }
                    break;
                    
                case '1': case '2': case '3': case '4': // Select tracks
                    selectedTrack = parseInt(e.key) - 1;
                    highlightTrack(selectedTrack);
                    break;
                    
                case 'ArrowLeft': // Previous step
                    e.preventDefault();
                    selectedStep = Math.max(0, selectedStep - 1);
                    highlightStep(selectedTrack, selectedStep);
                    break;
                    
                case 'ArrowRight': // Next step
                    e.preventDefault();
                    selectedStep = Math.min(15, selectedStep + 1);
                    highlightStep(selectedTrack, selectedStep);
                    break;
                    
                case 'ArrowUp': // Previous track
                    e.preventDefault();
                    selectedTrack = Math.max(0, selectedTrack - 1);
                    highlightTrack(selectedTrack);
                    break;
                    
                case 'ArrowDown': // Next track
                    e.preventDefault();
                    selectedTrack = Math.min(tracks.length - 1, selectedTrack + 1);
                    highlightTrack(selectedTrack);
                    break;
                    
                case 'Enter': // Toggle selected step
                    e.preventDefault();
                    toggleSelectedStep();
                    break;
                    
                case 'c': // Clear track
                case 'C':
                    clearTrack(tracks[selectedTrack]);
                    break;
                    
                case 'r': // Randomize track
                case 'R':
                    randomizeTrack(tracks[selectedTrack]);
                    break;
                    
                case '?': // Show help
                    showKeyboardHelp();
                    break;
            }
        });
        
        function highlightTrack(trackIndex) {
            document.querySelectorAll('.sequencer-track').forEach((track, i) => {
                if (i === trackIndex) {
                    track.style.background = 'rgba(255, 107, 53, 0.05)';
                    track.style.borderLeft = '3px solid var(--accent-orange)';
                } else {
                    track.style.background = '';
                    track.style.borderLeft = '';
                }
            });
        }
        
        function highlightStep(trackIndex, stepIndex) {
            const track = tracks[trackIndex];
            const grid = document.getElementById(`${track}-grid`);
            const steps = grid.querySelectorAll('.step');
            
            steps.forEach((step, i) => {
                if (i === stepIndex) {
                    step.style.boxShadow = '0 0 15px rgba(255, 107, 53, 0.8)';
                    step.style.borderWidth = '2px';
                } else {
                    step.style.boxShadow = '';
                    step.style.borderWidth = '';
                }
            });
        }
        
        function toggleSelectedStep() {
            const track = tracks[selectedTrack];
            const grid = document.getElementById(`${track}-grid`);
            const steps = grid.querySelectorAll('.step');
            const step = steps[selectedStep];
            if (step) {
                step.classList.toggle('active');
            }
        }
        
        function showKeyboardHelp() {
            const helpText = `
üéπ KEYBOARD SHORTCUTS

PLAYBACK:
‚Ä¢ SPACE - Play/Pause
‚Ä¢ ESC - Stop
‚Ä¢ Ctrl/Cmd + S - Save Pattern
‚Ä¢ Ctrl/Cmd + L - Load Pattern

NAVIGATION:
‚Ä¢ 1-4 - Select Track (Kick, Snare, HiHat, Bass)
‚Ä¢ ‚Üê ‚Üí - Previous/Next Step
‚Ä¢ ‚Üë ‚Üì - Previous/Next Track
‚Ä¢ ENTER - Toggle Selected Step

EDITING:
‚Ä¢ C - Clear Selected Track
‚Ä¢ R - Randomize Selected Track
‚Ä¢ ? - Show This Help
            `;
            alert(helpText);
        }

        // Initialize knobs on load
        window.addEventListener('DOMContentLoaded', () => {
            initKnobs();
            initBackground();
            
            // Setup BPM knob listener
            const bpmKnob = document.getElementById('bpmKnob');
            if (bpmKnob) {
                bpmKnob.addEventListener('change', (e) => {
                    currentBPM = Math.round(e.detail.value);
                    console.log('BPM changed to:', currentBPM);
                    
                    if (playing) {
                        clearInterval(interval);
                        interval = setInterval(stepSequencer, (60 / currentBPM) * 1000 / 4);
                    }
                });
            }
            
            // Show keyboard help on first load
            if (!localStorage.getItem('haos_help_shown')) {
                setTimeout(() => {
                    alert('üí° Tip: Press "?" to see keyboard shortcuts!');
                    localStorage.setItem('haos_help_shown', 'true');
                }, 2000);
            }
            
            // Initialize pitch control after DOM is ready
            setTimeout(() => {
                initializePitch();
            }, 100);
        });

        console.log('üéπ HAOS Techno Workspace - Ready with Web Audio!');
    </script>
    
    <!-- Initialize i18n Translation System -->
    <script>
        // Apply translations on page load
        document.addEventListener('DOMContentLoaded', () => {
            translatePage();
            
            // Update language toggle button text
            const langBtn = document.getElementById('languageToggle');
            if (langBtn) {
                langBtn.textContent = currentLanguage === 'pl' ? 'üáµüá± PL' : 'üá¨üáß EN';
            }
        });
    </script>
</body>
</html>
