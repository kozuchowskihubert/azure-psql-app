<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Behringer 2600 - Photo-Realistic 3D - HAOS.fm</title>
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Rajdhani', sans-serif;
      background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
      overflow: hidden;
      color: #fff;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    /* HUD */
    .hud {
      position: absolute;
      top: 2rem;
      left: 2rem;
      pointer-events: none;
      z-index: 10;
    }

    .logo {
      font-family: 'Orbitron', sans-serif;
      font-size: 3rem;
      font-weight: 900;
      letter-spacing: 4px;
      background: linear-gradient(135deg, #00d4ff, #0096ff);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 40px rgba(0, 212, 255, 0.6);
      margin-bottom: 0.5rem;
    }

    .subtitle {
      font-size: 1.2rem;
      color: #aaa;
      letter-spacing: 2px;
    }

    /* Controls */
    .controls {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 1rem;
      pointer-events: all;
      z-index: 10;
    }

    .control-btn {
      padding: 1rem 2rem;
      background: rgba(10, 10, 10, 0.9);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(0, 212, 255, 0.4);
      border-radius: 12px;
      color: #00d4ff;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .control-btn:hover {
      background: rgba(0, 212, 255, 0.2);
      border-color: #00d4ff;
      transform: translateY(-2px);
      box-shadow: 0 0 30px rgba(0, 212, 255, 0.6);
    }

    .control-btn.active {
      background: linear-gradient(135deg, #00d4ff, #0096ff);
      color: #000;
      border-color: #00d4ff;
    }

    /* Info Panel */
    .info-panel {
      position: absolute;
      top: 2rem;
      right: 2rem;
      background: rgba(10, 10, 10, 0.9);
      backdrop-filter: blur(10px);
      padding: 1.5rem;
      border-radius: 12px;
      border: 2px solid rgba(0, 212, 255, 0.3);
      min-width: 300px;
      pointer-events: all;
      z-index: 10;
    }

    .info-title {
      color: #00d4ff;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 1rem;
      border-bottom: 2px solid #00d4ff;
      padding-bottom: 0.5rem;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      margin: 0.75rem 0;
      font-size: 0.9rem;
    }

    .info-label {
      color: #888;
    }

    .info-value {
      color: #00d4ff;
      font-weight: 700;
    }

    /* Loading */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.5s;
    }

    .loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loader {
      width: 80px;
      height: 80px;
      border: 4px solid rgba(0, 212, 255, 0.1);
      border-top: 4px solid #00d4ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 2rem;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      color: #00d4ff;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
  </style>
</head>
<body>

  <div class="loading" id="loading">
    <div class="loader"></div>
    <div class="loading-text">Loading Behringer 2600</div>
  </div>

  <div id="canvas-container"></div>

  <div class="hud">
    <div class="logo">BEHRINGER</div>
    <div class="subtitle">2600 Gray Meanie - Photo-Realistic</div>
  </div>

  <div class="info-panel">
    <div class="info-title">Module Info</div>
    <div class="info-item">
      <span class="info-label">VCOs:</span>
      <span class="info-value">3 Oscillators</span>
    </div>
    <div class="info-item">
      <span class="info-label">Filter:</span>
      <span class="info-value">24dB Ladder</span>
    </div>
    <div class="info-item">
      <span class="info-label">Patch Points:</span>
      <span class="info-value">86 Points</span>
    </div>
    <div class="info-item">
      <span class="info-label">Controls:</span>
      <span class="info-value">104 Knobs</span>
    </div>
    <div class="info-item">
      <span class="info-label">Spring Reverb:</span>
      <span class="info-value">Built-in</span>
    </div>
  </div>

  <div class="controls">
    <button class="control-btn active" id="power-btn">âš¡ Power</button>
    <button class="control-btn" id="rotate-btn">ðŸ”„ Auto Rotate</button>
    <button class="control-btn" id="lights-btn">ðŸ’¡ Lights</button>
    <button class="control-btn" id="reset-btn">ðŸŽ¯ Reset View</button>
  </div>

  <script>
    // Three.js Scene
    let scene, camera, renderer, controls;
    let synthModel;
    let isAutoRotating = false;

    // ACCURATE BEHRINGER 2600 DIMENSIONS
    // Real Unit: 17.85" W x 24.75" H x 7.85" D
    // Scale: 1 unit = 1 inch in 3D space
    const SYNTH_WIDTH = 17.85;  // inches
    const SYNTH_HEIGHT = 24.75; // inches
    const SYNTH_DEPTH = 7.85;   // inches
    const SCALE = 0.3; // Scale down for viewport (actual dimensions * 0.3)

    // Accurate module layout based on ARP 2600 / Behringer 2600 Gray Meanie
    const moduleLayout = {
      // Left Column - Oscillators
      vco1: {
        position: { x: -1.8, z: -0.9 },
        width: 0.9,
        height: 1.2,
        knobs: [
          { name: 'FREQUENCY', x: 0.2, z: 0.2, size: 0.12 },
          { name: 'FINE', x: 0.6, z: 0.2, size: 0.09 },
          { name: 'WAVEFORM', x: 0.2, z: 0.6, size: 0.08 },
          { name: 'PW', x: 0.6, z: 0.6, size: 0.09 }
        ],
        color: 0x4a4a4a, // Dark gray
        labelColor: 0xffffff
      },
      vco2: {
        position: { x: -0.6, z: -0.9 },
        width: 0.9,
        height: 1.2,
        knobs: [
          { name: 'FREQUENCY', x: 0.2, z: 0.2, size: 0.12 },
          { name: 'FINE', x: 0.6, z: 0.2, size: 0.09 },
          { name: 'WAVEFORM', x: 0.2, z: 0.6, size: 0.08 },
          { name: 'PW', x: 0.6, z: 0.6, size: 0.09 }
        ],
        color: 0x4a4a4a,
        labelColor: 0xffffff
      },
      vco3: {
        position: { x: 0.6, z: -0.9 },
        width: 0.9,
        height: 1.2,
        knobs: [
          { name: 'FREQUENCY', x: 0.2, z: 0.2, size: 0.12 },
          { name: 'FINE', x: 0.6, z: 0.2, size: 0.09 },
          { name: 'WAVEFORM', x: 0.2, z: 0.6, size: 0.08 }
        ],
        color: 0x4a4a4a,
        labelColor: 0xffffff
      },
      
      // Center Column - Mixer & Filter
      mixer: {
        position: { x: -1.2, z: 0.5 },
        width: 1.2,
        height: 1.0,
        knobs: [
          { name: 'VCO1', x: 0.15, z: 0.3, size: 0.08 },
          { name: 'VCO2', x: 0.35, z: 0.3, size: 0.08 },
          { name: 'VCO3', x: 0.55, z: 0.3, size: 0.08 },
          { name: 'NOISE', x: 0.75, z: 0.3, size: 0.08 },
          { name: 'EXT', x: 0.95, z: 0.3, size: 0.08 }
        ],
        color: 0x606060, // Medium gray
        labelColor: 0xffffff
      },
      vcf: {
        position: { x: 0.3, z: 0.5 },
        width: 1.3,
        height: 1.0,
        knobs: [
          { name: 'CUTOFF', x: 0.2, z: 0.3, size: 0.13 },
          { name: 'RESONANCE', x: 0.5, z: 0.3, size: 0.13 },
          { name: 'MOD', x: 0.8, z: 0.3, size: 0.10 },
          { name: 'KEYBOARD', x: 0.35, z: 0.7, size: 0.09 }
        ],
        color: 0x5a5a5a,
        labelColor: 0xffffff
      },
      
      // Right Column - Envelopes & VCA
      adsr: {
        position: { x: 1.8, z: 0.5 },
        width: 1.1,
        height: 1.0,
        knobs: [
          { name: 'ATTACK', x: 0.15, z: 0.3, size: 0.10 },
          { name: 'DECAY', x: 0.4, z: 0.3, size: 0.10 },
          { name: 'SUSTAIN', x: 0.65, z: 0.3, size: 0.10 },
          { name: 'RELEASE', x: 0.9, z: 0.3, size: 0.10 }
        ],
        color: 0x4a4a4a,
        labelColor: 0xffffff
      },
      vca: {
        position: { x: -1.5, z: 1.7 },
        width: 0.8,
        height: 0.7,
        knobs: [
          { name: 'LEVEL', x: 0.3, z: 0.3, size: 0.12 },
          { name: 'GAIN', x: 0.6, z: 0.3, size: 0.09 }
        ],
        color: 0x5a5a5a,
        labelColor: 0xffffff
      },
      
      // Modulation Section
      lfo: {
        position: { x: -0.4, z: 1.7 },
        width: 0.8,
        height: 0.7,
        knobs: [
          { name: 'RATE', x: 0.3, z: 0.3, size: 0.10 },
          { name: 'WAVE', x: 0.6, z: 0.3, size: 0.08 }
        ],
        color: 0x505870, // Blue-gray for modulation
        labelColor: 0xffffff
      },
      ringMod: {
        position: { x: 0.5, z: 1.7 },
        width: 0.6,
        height: 0.7,
        knobs: [],
        color: 0x505870,
        labelColor: 0xffffff
      },
      sampleHold: {
        position: { x: 1.2, z: 1.7 },
        width: 0.7,
        height: 0.7,
        knobs: [
          { name: 'RATE', x: 0.4, z: 0.3, size: 0.09 }
        ],
        color: 0x505870,
        labelColor: 0xffffff
      },
      
      // Noise Generator
      noise: {
        position: { x: 2.0, z: 1.7 },
        width: 0.6,
        height: 0.7,
        knobs: [
          { name: 'LEVEL', x: 0.4, z: 0.3, size: 0.09 }
        ],
        color: 0x606060,
        labelColor: 0xffffff
      }
    };

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);
      scene.fog = new THREE.Fog(0x0a0a0a, 10, 60);

      // Camera
      camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 10);
      camera.lookAt(0, 0, 0);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.3;
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // Orbit Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 4;
      controls.maxDistance = 20;
      controls.maxPolarAngle = Math.PI / 2;
      controls.target.set(0, 0, 0);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
      keyLight.position.set(8, 12, 8);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.width = 4096;
      keyLight.shadow.mapSize.height = 4096;
      keyLight.shadow.camera.near = 0.5;
      keyLight.shadow.camera.far = 50;
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0x00d4ff, 0.4);
      fillLight.position.set(-8, 8, -8);
      scene.add(fillLight);

      const rimLight = new THREE.DirectionalLight(0x0096ff, 0.6);
      rimLight.position.set(0, 8, -15);
      scene.add(rimLight);

      // Point lights for realism
      const pointLight1 = new THREE.PointLight(0x00d4ff, 1.5, 15);
      pointLight1.position.set(-5, 3, 5);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0x0096ff, 1.5, 15);
      pointLight2.position.set(5, 3, 5);
      scene.add(pointLight2);

      // Create synth
      createBehringer2600();

      // Ground
      const groundGeometry = new THREE.PlaneGeometry(40, 40);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x0a0a0a,
        roughness: 0.9,
        metalness: 0.1
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.6;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid
      const gridHelper = new THREE.GridHelper(30, 50, 0x00d4ff, 0x1a1a2e);
      gridHelper.position.y = -0.59;
      gridHelper.material.opacity = 0.3;
      gridHelper.material.transparent = true;
      scene.add(gridHelper);

      // UI
      setupUI();
      animate();

      // Hide loading
      setTimeout(() => {
        document.getElementById('loading').classList.add('hidden');
      }, 1500);

      window.addEventListener('resize', onWindowResize);
    }

    function createBehringer2600() {
      synthModel = new THREE.Group();

      // ACCURATE DIMENSIONS - Behringer 2600 Gray Meanie
      // Real: 17.85" W x 24.75" H x 7.85" D
      // Scaled for viewport
      const width = SYNTH_WIDTH * SCALE;   // ~5.4 units
      const height = SYNTH_HEIGHT * SCALE; // ~7.4 units
      const depth = SYNTH_DEPTH * SCALE;   // ~2.4 units

      // Main wooden case base (walnut finish)
      const baseGeometry = new THREE.BoxGeometry(width + 0.3, 0.4, depth);
      const baseMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a3422, // Walnut brown
        roughness: 0.7,
        metalness: 0.1,
        map: createWoodTexture()
      });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = -0.2;
      base.castShadow = true;
      base.receiveShadow = true;
      synthModel.add(base);

      // Main control panel (angled, light gray aluminum)
      const panelWidth = width;
      const panelDepth = depth * 0.9;
      const panelGeometry = new THREE.BoxGeometry(panelWidth, 0.08, panelDepth);
      const panelMaterial = new THREE.MeshStandardMaterial({
        color: 0xc8c8c8, // Light aluminum gray
        roughness: 0.25,
        metalness: 0.6,
        envMapIntensity: 1.0
      });
      const panel = new THREE.Mesh(panelGeometry, panelMaterial);
      panel.position.set(0, 0.2, 0);
      panel.rotation.x = -0.15; // 8.6 degree angle (typical desktop synth tilt)
      panel.castShadow = true;
      panel.receiveShadow = true;
      synthModel.add(panel);

      // Wooden side cheeks (walnut)
      const sideGeometry = new THREE.BoxGeometry(0.3, 0.8, depth);
      const sideLeft = new THREE.Mesh(sideGeometry, baseMaterial);
      sideLeft.position.set(-(width + 0.3) / 2 + 0.15, 0.2, 0);
      sideLeft.castShadow = true;
      synthModel.add(sideLeft);

      const sideRight = new THREE.Mesh(sideGeometry, baseMaterial);
      sideRight.position.set((width + 0.3) / 2 - 0.15, 0.2, 0);
      sideRight.castShadow = true;
      synthModel.add(sideRight);

      // Front panel strip (dark wood)
      const frontStripGeometry = new THREE.BoxGeometry(panelWidth, 0.5, 0.2);
      const frontStrip = new THREE.Mesh(frontStripGeometry, baseMaterial);
      frontStrip.position.set(0, 0.15, depth / 2 + 0.1);
      frontStrip.castShadow = true;
      synthModel.add(frontStrip);

      // Back panel
      const backPanel = new THREE.Mesh(frontStripGeometry, baseMaterial);
      backPanel.position.set(0, 0.15, -depth / 2 - 0.1);
      backPanel.castShadow = true;
      synthModel.add(backPanel);

      // Create all modules with accurate positioning
      Object.keys(moduleLayout).forEach(moduleName => {
        const module = moduleLayout[moduleName];
        createModule(module, moduleName);
      });

      // Create realistic patch bay (86 patch points in matrix)
      createPatchBay();

      // Add authentic patch cables
      createPatchCables();

      // Behringer logo and branding
      createLogo();

      // Add sliders for additional controls
      createSliders();

      scene.add(synthModel);
    }

    // Create wood grain texture
    function createWoodTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Wood grain pattern
      const gradient = ctx.createLinearGradient(0, 0, 512, 0);
      gradient.addColorStop(0, '#3d2817');
      gradient.addColorStop(0.3, '#4a3422');
      gradient.addColorStop(0.7, '#3d2817');
      gradient.addColorStop(1, '#4a3422');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);
      
      // Add grain lines
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 30; i++) {
        ctx.beginPath();
        ctx.moveTo(Math.random() * 512, 0);
        ctx.lineTo(Math.random() * 512, 512);
        ctx.stroke();
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      return texture;
    }

    function createModule(module, moduleName) {
      const moduleGroup = new THREE.Group();
      
      // Module section background (color-coded like original ARP 2600)
      const sectionGeometry = new THREE.PlaneGeometry(module.width, module.height);
      const sectionMaterial = new THREE.MeshStandardMaterial({
        color: module.color,
        roughness: 0.3,
        metalness: 0.5
      });
      const section = new THREE.Mesh(sectionGeometry, sectionMaterial);
      section.rotation.x = -Math.PI / 2 - 0.15;
      section.position.y = 0.01;
      moduleGroup.add(section);

      // Section border (raised edge)
      const borderGeometry = new THREE.BoxGeometry(module.width + 0.02, 0.02, module.height + 0.02);
      const borderMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.6,
        metalness: 0.3
      });
      const border = new THREE.Mesh(borderGeometry, borderMaterial);
      border.position.y = 0.03;
      border.rotation.x = -0.15;
      moduleGroup.add(border);

      // Add knobs with accurate sizing
      module.knobs.forEach(knobData => {
        const knob = createKnob(knobData.size || 0.1);
        const knobX = module.position.x + knobData.x - module.width / 2;
        const knobZ = module.position.z + knobData.z - module.height / 2;
        knob.position.set(knobX, 0.35, knobZ);
        knob.userData = { name: knobData.name, module: moduleName };
        synthModel.add(knob);
      });

      moduleGroup.position.set(module.position.x, 0.2, module.position.z);
      synthModel.add(moduleGroup);
    }

    function createKnob(size = 0.1) {
      const knobGroup = new THREE.Group();

      // Knob base (black plastic with ribbed texture)
      const baseGeometry = new THREE.CylinderGeometry(size, size * 0.85, size * 1.2, 32);
      const baseMaterial = new THREE.MeshStandardMaterial({
        color: 0x0f0f0f,
        roughness: 0.5,
        metalness: 0.6
      });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.castShadow = true;
      knobGroup.add(base);

      // Knob top (slightly lighter)
      const topGeometry = new THREE.CylinderGeometry(size * 0.95, size * 0.95, size * 0.2, 32);
      const topMaterial = new THREE.MeshStandardMaterial({
        color: 0x1f1f1f,
        roughness: 0.3,
        metalness: 0.7
      });
      const top = new THREE.Mesh(topGeometry, topMaterial);
      top.position.y = size * 0.7;
      knobGroup.add(top);

      // White indicator line (pointer)
      const indicatorGeometry = new THREE.BoxGeometry(size * 0.12, size * 0.5, size * 0.12);
      const indicatorMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xcccccc,
        emissiveIntensity: 0.3
      });
      const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
      indicator.position.y = size * 0.4;
      indicator.position.z = size * 0.85;
      knobGroup.add(indicator);

      // Add metallic shaft
      const shaftGeometry = new THREE.CylinderGeometry(size * 0.25, size * 0.25, size * 0.4, 16);
      const shaftMaterial = new THREE.MeshStandardMaterial({
        color: 0x888888,
        roughness: 0.2,
        metalness: 0.95
      });
      const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
      shaft.position.y = -size * 0.4;
      knobGroup.add(shaft);

      return knobGroup;
    }

    function createPatchBay() {
      // Accurate patch bay matrix - 86 patch points
      // Arranged in organized rows based on signal type
      const patchRadius = 0.025;
      const patchHeight = 0.06;
      const patchGeometry = new THREE.CylinderGeometry(patchRadius, patchRadius, patchHeight, 16);
      const patchMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.15,
        metalness: 0.95,
        envMapIntensity: 1.5
      });

      // Patch bay section (darker area)
      const patchBayBg = new THREE.PlaneGeometry(5, 0.9);
      const patchBayMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.7,
        metalness: 0.2
      });
      const patchBay = new THREE.Mesh(patchBayBg, patchBayMaterial);
      patchBay.rotation.x = -Math.PI / 2 - 0.15;
      patchBay.position.set(0, 0.21, 1.15);
      synthModel.add(patchBay);

      // Create organized patch point matrix
      // 6 rows of varying lengths to match original layout
      const patchLayout = [
        14, // Row 1 - Outputs
        14, // Row 2 - VCO/VCF
        15, // Row 3 - Envelopes
        15, // Row 4 - Modulation
        14, // Row 5 - Control
        14  // Row 6 - Inputs
      ];

      let totalPoints = 0;
      patchLayout.forEach((count, row) => {
        const startX = -(count * 0.17) / 2;
        for (let col = 0; col < count; col++) {
          const patchPoint = new THREE.Mesh(patchGeometry, patchMaterial);
          patchPoint.position.set(
            startX + col * 0.17,
            0.27,
            0.7 + row * 0.14
          );
          patchPoint.rotation.x = Math.PI / 2 + 0.15;
          patchPoint.castShadow = true;
          patchPoint.userData = { type: 'patchPoint', row, col };
          synthModel.add(patchPoint);
          totalPoints++;
        }
      });

      console.log(`Created ${totalPoints} patch points`);
    }

    function createPatchCables() {
      // Authentic Behringer/ARP 2600 patch cable colors
      const cableColors = [
        { color: 0xff0000, name: 'Red' },      // VCO outputs
        { color: 0x0000ff, name: 'Blue' },     // Filter outputs
        { color: 0xffff00, name: 'Yellow' },   // Envelope outputs
        { color: 0x000000, name: 'Black' },    // Ground/CV
        { color: 0xffffff, name: 'White' },    // Audio signals
        { color: 0xff6600, name: 'Orange' },   // Modulation
        { color: 0x00ff00, name: 'Green' },    // Gate/Trigger
        { color: 0xff00ff, name: 'Magenta' },  // LFO
        { color: 0x00ffff, name: 'Cyan' },     // Sample & Hold
        { color: 0x964b00, name: 'Brown' },    // Noise
        { color: 0xff1493, name: 'Pink' },     // Ring Mod
        { color: 0x4169e1, name: 'Royal Blue' }
      ];

      // Create realistic cable connections
      for (let i = 0; i < 12; i++) {
        const cableData = cableColors[i];
        
        // Random but realistic patch point positions
        const startX = -2.2 + (i % 7) * 0.6;
        const startZ = 0.75 + Math.floor(i / 7) * 0.3;
        const endX = -1.8 + ((i + 3) % 7) * 0.6;
        const endZ = 1.0 + Math.floor((i + 2) / 7) * 0.3;
        
        // Natural cable sag curve
        const midY = 0.35 + Math.random() * 0.25;
        const controlPoint1 = new THREE.Vector3(
          startX + (endX - startX) * 0.3,
          midY,
          startZ + (endZ - startZ) * 0.3
        );
        const controlPoint2 = new THREE.Vector3(
          startX + (endX - startZ) * 0.7,
          midY + Math.random() * 0.1,
          startZ + (endZ - startZ) * 0.7
        );

        const curve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(startX, 0.27, startZ),
          controlPoint1,
          controlPoint2,
          new THREE.Vector3(endX, 0.27, endZ)
        ]);

        // Cable body (flexible, slightly shiny)
        const cableGeometry = new THREE.TubeGeometry(curve, 32, 0.015, 12, false);
        const cableMaterial = new THREE.MeshStandardMaterial({
          color: cableData.color,
          roughness: 0.4,
          metalness: 0.2
        });
        const cable = new THREE.Mesh(cableGeometry, cableMaterial);
        cable.castShadow = true;
        cable.userData = { type: 'cable', name: cableData.name };
        synthModel.add(cable);

        // 1/4" TS cable jacks (chrome finish)
        const jackGeometry = new THREE.CylinderGeometry(0.022, 0.028, 0.07, 16);
        const jackMaterial = new THREE.MeshStandardMaterial({
          color: 0x888888,
          roughness: 0.15,
          metalness: 0.95,
          envMapIntensity: 2.0
        });

        // Jack tip (black plastic)
        const tipGeometry = new THREE.CylinderGeometry(0.018, 0.018, 0.03, 16);
        const tipMaterial = new THREE.MeshStandardMaterial({
          color: 0x0a0a0a,
          roughness: 0.6,
          metalness: 0.2
        });

        // Start jack
        const jack1 = new THREE.Mesh(jackGeometry, jackMaterial);
        jack1.position.set(startX, 0.31, startZ);
        jack1.rotation.x = Math.PI / 2 + 0.15;
        jack1.castShadow = true;
        synthModel.add(jack1);

        const tip1 = new THREE.Mesh(tipGeometry, tipMaterial);
        tip1.position.set(startX, 0.32, startZ);
        tip1.rotation.x = Math.PI / 2 + 0.15;
        synthModel.add(tip1);

        // End jack
        const jack2 = new THREE.Mesh(jackGeometry, jackMaterial);
        jack2.position.set(endX, 0.31, endZ);
        jack2.rotation.x = Math.PI / 2 + 0.15;
        jack2.castShadow = true;
        synthModel.add(jack2);

        const tip2 = new THREE.Mesh(tipGeometry, tipMaterial);
        tip2.position.set(endX, 0.32, endZ);
        tip2.rotation.x = Math.PI / 2 + 0.15;
        synthModel.add(tip2);
      }
    }

    function createLogo() {
      // Behringer logo area (blue bar with text)
      const logoBarGeometry = new THREE.PlaneGeometry(2.5, 0.25);
      const logoBarMaterial = new THREE.MeshStandardMaterial({
        color: 0x1e5fa8, // Behringer blue
        emissive: 0x1e5fa8,
        emissiveIntensity: 0.4,
        roughness: 0.3,
        metalness: 0.6
      });
      const logoBar = new THREE.Mesh(logoBarGeometry, logoBarMaterial);
      logoBar.position.set(-1.5, 0.211, -0.95);
      logoBar.rotation.x = -Math.PI / 2 - 0.15;
      synthModel.add(logoBar);

      // "2600" model designation
      const modelGeometry = new THREE.PlaneGeometry(1.2, 0.3);
      const modelMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xdddddd,
        emissiveIntensity: 0.5,
        roughness: 0.2
      });
      const modelText = new THREE.Mesh(modelGeometry, modelMaterial);
      modelText.position.set(0.5, 0.211, -0.95);
      modelText.rotation.x = -Math.PI / 2 - 0.15;
      synthModel.add(modelText);

      // "GRAY MEANIE" subtitle (if Gray Meanie version)
      const subtitleGeometry = new THREE.PlaneGeometry(1.5, 0.12);
      const subtitleMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        emissive: 0x999999,
        emissiveIntensity: 0.3,
        roughness: 0.4
      });
      const subtitle = new THREE.Mesh(subtitleGeometry, subtitleMaterial);
      subtitle.position.set(2, 0.211, -0.95);
      subtitle.rotation.x = -Math.PI / 2 - 0.15;
      synthModel.add(subtitle);
    }

    function createSliders() {
      // Add vertical sliders for certain parameters (authentic to original design)
      const sliderPositions = [
        { x: -2.2, z: -0.3, height: 0.4, color: 0x333333 },
        { x: -1.8, z: -0.3, height: 0.4, color: 0x333333 },
        { x: 1.0, z: -0.3, height: 0.4, color: 0x333333 }
      ];

      sliderPositions.forEach(pos => {
        // Slider track
        const trackGeometry = new THREE.BoxGeometry(0.05, 0.02, pos.height);
        const trackMaterial = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.7,
          metalness: 0.3
        });
        const track = new THREE.Mesh(trackGeometry, trackMaterial);
        track.position.set(pos.x, 0.25, pos.z);
        track.rotation.x = -0.15;
        synthModel.add(track);

        // Slider cap (movable part)
        const capGeometry = new THREE.BoxGeometry(0.12, 0.08, 0.06);
        const capMaterial = new THREE.MeshStandardMaterial({
          color: pos.color,
          roughness: 0.4,
          metalness: 0.6
        });
        const cap = new THREE.Mesh(capGeometry, capMaterial);
        cap.position.set(pos.x, 0.28, pos.z + Math.random() * 0.2 - 0.1);
        cap.rotation.x = -0.15;
        cap.castShadow = true;
        cap.userData = { type: 'slider' };
        synthModel.add(cap);
      });
    }

    function setupUI() {
      document.getElementById('power-btn').addEventListener('click', function() {
        this.classList.toggle('active');
      });

      document.getElementById('rotate-btn').addEventListener('click', function() {
        isAutoRotating = !isAutoRotating;
        this.classList.toggle('active');
        controls.autoRotate = isAutoRotating;
        controls.autoRotateSpeed = 1.5;
      });

      document.getElementById('lights-btn').addEventListener('click', function() {
        this.classList.toggle('active');
        const isLit = this.classList.contains('active');
        scene.children.forEach(child => {
          if (child instanceof THREE.PointLight) {
            child.intensity = isLit ? 3 : 1.5;
          }
        });
      });

      document.getElementById('reset-btn').addEventListener('click', function() {
        camera.position.set(0, 5, 10);
        controls.target.set(0, 0, 0);
        controls.update();
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.addEventListener('load', init);
  </script>

</body>
</html>
